act_build.c:      key_obj->vnum = key_vnum;
act_build.c:      key_obj->area = ch->in_room->area;
act_build.c:      key_obj->next = obj_index_hash[iHash];
act_build.c:      free_string (key_obj->name);
act_build.c:      free_string (key_obj->short_descr);
act_build.c:      free_string (key_obj->description);
act_build.c:      free_string (key_obj->material);
act_build.c:      key_obj->value[0] = TRUE;
act_build.c:      key_obj->name = str_dup ("key room");
act_build.c:      key_obj->short_descr = str_dup (tcbuf);
act_build.c:	  key_obj->description = str_dup (tcbuf);
act_build.c:	  key_obj->description = str_dup (tcbuf);
act_build.c:      key_obj->material = str_dup ("metal");
act_build.c:      key_obj->item_type = ITEM_KEY;
act_build.c:      key_obj->wear_flags = A;
act_build.c:      key_obj->weight = 10;
act_comm.c:      obj_next = obj->next_content;
act_comm.c:	  if (obj->wear_loc != WEAR_NONE)
act_comm.c:                  && obj->item_type == ITEM_LIGHT
act_comm.c:	    && obj->value[2] != 0 && ch->in_room != NULL))
act_comm.c:                  && obj->item_type == ITEM_LIGHT
act_comm.c:	    && obj->value[2] != 0 && ch->in_room != NULL))
act_comm.c:       obj_next = obj->next_content;
act_comm.c:         if (obj->wear_loc != WEAR_NONE)
act_comm.c:	  obj_next = obj->next_content;
act_comm.c:	  obj_next = obj->next_content;
act_comm.c:	      && (obj->wear_loc == WEAR_WIELD_L
act_comm.c:		  || obj->wear_loc == WEAR_WIELD_R))
act_comm.c:	  if (obj->wear_loc != WEAR_NONE)
act_comm.c:	      obj_next = obj->next_content;
act_comm.c:	      if (IS_CLASS(ch,PC_CLASS_REAVER) && (obj->wear_loc == WEAR_WIELD_L || obj->wear_loc == WEAR_WIELD_R))
act_comm.c:	      if (obj->wear_loc != WEAR_NONE)
act_enter.c:  if (obj->item_type != ITEM_CTRANSPORT
act_enter.c:      || !(IS_SET (obj->value[4], TACT_SAIL)
act_enter.c:	   || IS_SET (obj->value[4], TACT_PADDLE)
act_enter.c:	   || IS_SET (obj->value[4], TACT_ROW)))
act_enter.c:	  for (obj = object_list; obj != NULL; obj = obj->next)
act_enter.c:	      if (obj->pIndexData->vnum == portal->value[3]
act_enter.c:		  && obj->in_room != NULL)
act_enter.c:		  location = get_room_index (obj->in_room->vnum);
act_enter.c:	      if (obj->pIndexData->vnum == portal->value[3]
act_enter.c:		  && obj->carried_by != NULL)
act_enter.c:		  location = obj->carried_by->in_room;
act_enter.c:	  for (obj = object_list; obj != NULL; obj = obj->next)
act_enter.c:	      if (obj->pIndexData->vnum == portal->value[3]
act_enter.c:		  && obj->in_room != NULL)
act_enter.c:		  location = get_room_index (obj->in_room->vnum);
act_enter.c:	      if (obj->pIndexData->vnum == portal->value[3]
act_enter.c:		  && obj->carried_by != NULL)
act_enter.c:		  location = obj->carried_by->in_room;
act_enter.c:	  for (obj = object_list; obj != NULL; obj = obj->next)
act_enter.c:	      if (obj->pIndexData->vnum == portal->value[3]
act_enter.c:		  && obj->in_room != NULL)
act_enter.c:		  location = get_room_index (obj->in_room->vnum);
act_enter.c:	      if (obj->pIndexData->vnum == portal->value[3]
act_enter.c:		  && obj->carried_by != NULL)
act_enter.c:		  location = obj->carried_by->in_room;
act_enter.c:	  for (obj = object_list; obj != NULL; obj = obj->next)
act_enter.c:	      if (obj->pIndexData->vnum == portal->value[3]
act_enter.c:		  && obj->in_room != NULL)
act_enter.c:		  location = get_room_index (obj->in_room->vnum);
act_enter.c:	      if (obj->pIndexData->vnum == portal->value[3]
act_enter.c:		  && obj->carried_by != NULL)
act_enter.c:		  location = obj->carried_by->in_room;
act_enter.c:	  for (obj = object_list; obj != NULL; obj = obj->next)
act_enter.c:	      if (obj->pIndexData->vnum == portal->value[3]
act_enter.c:		  && obj->in_room != NULL)
act_enter.c:		  location = get_room_index (obj->in_room->vnum);
act_enter.c:	      if (obj->pIndexData->vnum == portal->value[3]
act_enter.c:		  && obj->carried_by != NULL)
act_enter.c:		  location = obj->carried_by->in_room;
act_enter.c:	  for (obj = object_list; obj != NULL; obj = obj->next)
act_enter.c:	      if (obj->pIndexData->vnum == portal->value[3]
act_enter.c:		  && obj->in_room != NULL)
act_enter.c:		  location = get_room_index (obj->in_room->vnum);
act_enter.c:	      if (obj->pIndexData->vnum == portal->value[3]
act_enter.c:		  && obj->carried_by != NULL)
act_enter.c:		  location = obj->carried_by->in_room;
act_enter.c:	  for (obj = object_list; obj != NULL; obj = obj->next)
act_enter.c:	      if (obj->pIndexData->vnum == portal->value[3]
act_enter.c:		  && obj->in_room != NULL)
act_enter.c:		  location = get_room_index (obj->in_room->vnum);
act_enter.c:	      if (obj->pIndexData->vnum == portal->value[3]
act_enter.c:		  && obj->carried_by != NULL)
act_enter.c:		  location = obj->carried_by->in_room;
act_enter.c:	  for (obj = object_list; obj != NULL; obj = obj->next)
act_enter.c:	      if (obj->pIndexData->vnum == portal->value[3]
act_enter.c:		  && obj->in_room != NULL)
act_enter.c:		  location = get_room_index (obj->in_room->vnum);
act_enter.c:	      if (obj->pIndexData->vnum == portal->value[3]
act_enter.c:		  && obj->carried_by != NULL)
act_enter.c:		  location = obj->carried_by->in_room;
act_enter.c:	  for (obj = object_list; obj != NULL; obj = obj->next)
act_enter.c:	      if (obj->pIndexData->vnum == portal->value[3]
act_enter.c:		  && obj->in_room != NULL)
act_enter.c:		  location = get_room_index (obj->in_room->vnum);
act_enter.c:	      if (obj->pIndexData->vnum == portal->value[3]
act_enter.c:		  && obj->carried_by != NULL)
act_enter.c:		  location = obj->carried_by->in_room;
act_enter.c:	  for (obj = object_list; obj != NULL; obj = obj->next)
act_enter.c:	      if (obj->pIndexData->vnum == portal->value[3]
act_enter.c:		  && obj->in_room != NULL)
act_enter.c:		  location = get_room_index (obj->in_room->vnum);
act_enter.c:	      if (obj->pIndexData->vnum == portal->value[3]
act_enter.c:		  && obj->carried_by != NULL)
act_enter.c:		  location = obj->carried_by->in_room;
act_enter.c:	  for (obj = object_list; obj != NULL; obj = obj->next)
act_enter.c:	      if (obj->pIndexData->vnum == portal->value[3]
act_enter.c:		  && obj->in_room != NULL)
act_enter.c:		  location = get_room_index (obj->in_room->vnum);
act_enter.c:	      if (obj->pIndexData->vnum == portal->value[3]
act_enter.c:		  && obj->carried_by != NULL)
act_enter.c:		  location = obj->carried_by->in_room;
act_enter.c:          for (obj = object_list; obj != NULL; obj = obj->next)
act_enter.c:              if (obj->pIndexData->vnum == portal->value[3]
act_enter.c:                  && obj->in_room != NULL)
act_enter.c:                  location = get_room_index (obj->in_room->vnum);
act_enter.c:              if (obj->pIndexData->vnum == portal->value[3]
act_enter.c:                  && obj->carried_by != NULL)
act_enter.c:                  location = obj->carried_by->in_room;
act_info.c:		if (eObj->pIndexData->vnum == obj->value[0])
act_info.c:		if (edest->vnum == obj->value[2])
act_info.c:	if ((fShort && (obj->short_descr == NULL || obj->short_descr[0] == '\0')))
act_info.c:	if (IS_SET(obj->extra_flags[1],ITEM_WINGED))
act_info.c:	if (IS_SET (obj->extra_flags[1], ITEM_WIZI))
act_info.c:	if (IS_SET(obj->extra_flags[1],ITEM_PULSATING))
act_info.c:	if (obj->item_type == ITEM_EBUTTON)
act_info.c:			if (IS_SET (obj->value[3], BUTTON_PULL))
act_info.c:			if (obj->short_descr != NULL)
act_info.c:				strcat (buf, obj->short_descr);
act_info.c:			if (obj->description != NULL)
act_info.c:				if (obj->pIndexData->vnum == OBJ_VNUM_CLAN_SYMBOL)
act_info.c:					sprintf (buf + strlen (buf), obj->description,
act_info.c:					strcat (buf, obj->description);
act_info.c:	for (obj = list; obj != NULL && obj->next_content != obj;
act_info.c:		obj = obj->next_content)
act_info.c:	for (obj = list; obj != NULL && obj->next_content != obj;
act_info.c:		obj = obj->next_content)
act_info.c:		if ((obj->item_type == ITEM_FURNITURE || obj->item_type == ITEM_RAFT) && obj->pIndexData->vnum != OBJ_VNUM_HEXAGRAM)
act_info.c:			if (obj->value[0] > 0 && count_users (obj) >= obj->value[0])
act_info.c:		if (obj->wear_loc == WEAR_NONE && can_see_obj (ch, obj)
act_info.c:			&& obj->description[0] != '\0')
act_info.c:	for (obj = list; obj != NULL; obj = obj->next_content)
act_info.c:	for (obj = list; obj != NULL; obj = obj->next_content)
act_info.c:		if ((obj->item_type == ITEM_FURNITURE || obj->item_type == ITEM_RAFT) && obj->pIndexData->vnum != OBJ_VNUM_HEXAGRAM)
act_info.c:			if (obj->value[0] > 0 && count_users (obj) >= obj->value[0])
act_info.c:		if (obj->wear_loc == WEAR_NONE && can_see_obj (ch, obj))
act_info.c:				&& IS_SET(obj->wear_loc,ITEM_WEAR_ANOTHER_WRIST))
act_info.c:				&& IS_SET(obj->wear_loc,ITEM_WEAR_ANOTHER_FINGER))
act_info.c:				&& IS_SET(obj->wear_loc,ITEM_WEAR_ANOTHER_NECK))
act_info.c:				&&  IS_SET(obj->wear_loc,ITEM_TWO_HANDS))
act_info.c:				if (!IS_SET(obj->wear_loc,wear_conversion_table[k].wear_flag))
act_info.c:					&& IS_SET(obj->wear_flags,ITEM_WEAR_ANOTHER_WRIST))
act_info.c:					&& IS_SET(obj->wear_flags,ITEM_WEAR_ANOTHER_FINGER))
act_info.c:					&& IS_SET(obj->wear_flags,ITEM_WEAR_ANOTHER_NECK))
act_info.c:					&& IS_SET(obj->wear_loc,ITEM_TWO_HANDS))
act_info.c:		for (tobj = ch->in_room->contents;tobj != NULL;tobj = tobj->next_content)
act_info.c:			if (IS_SET(tobj->extra_flags[1],ITEM_PULSATING))
act_info.c:		for (tobj = ch->in_room->contents;tobj != NULL;tobj = tobj->next_content)
act_info.c:			if (IS_SET(tobj->extra_flags[1],ITEM_PULSATING))
act_info.c:		switch (obj->item_type)
act_info.c:			if (!IS_SET (obj->value[4], PACT_EXIT))
act_info.c:			if (IS_SET (obj->value[1], EX_CLOSED))
act_info.c:			location = get_room_index (obj->value[3]);
act_info.c:				obj->short_descr);
act_info.c:		switch (obj->item_type)
act_info.c:			location = get_room_index (obj->value[0]);
act_info.c:			if (obj->value[3] == PORTAL_FUCKED)
act_info.c:			if (IS_SET (obj->value[1], EX_CLOSED))
act_info.c:			if (IS_SET (obj->value[4], PACT_PLAY))
act_info.c:			if (IS_SET (obj->value[4], PACT_EXIT))
act_info.c:					obj->short_descr);
act_info.c:			if (IS_SET (obj->value[4], PACT_CLIMB)
act_info.c:				|| IS_SET (obj->value[4], PACT_DESCEND)
act_info.c:				|| IS_SET (obj->value[4], PACT_CRAWL)
act_info.c:				|| IS_SET (obj->value[4], PACT_SCALE)
act_info.c:				|| IS_SET (obj->value[4], PACT_JUMP))
act_info.c:			location = get_room_index (obj->value[3]);
act_info.c:				obj->short_descr);
act_info.c:			if (obj->value[1] <= 0)
act_info.c:			if (obj->value[2] >= 0)
act_info.c:				obj->value[1] <
act_info.c:				obj->value[0] /
act_info.c:				4 ? "less than half-" : obj->value[1] <
act_info.c:				3 * obj->value[0] /
act_info.c:				liq_table[obj->value[2]].liq_color);
act_info.c:				obj->value[1] <
act_info.c:				obj->value[0] /
act_info.c:				4 ? "less than half-" : obj->value[1] <
act_info.c:				3 * obj->value[0] /
act_info.c:			show_list_to_char (obj->contains, ch, TRUE, TRUE);
act_info.c:			if (IS_SET (obj->value[1], CONT_CLOSED))
act_info.c:			show_list_to_char (obj->contains, ch, TRUE, TRUE);
act_info.c:	for (obj = ch->carrying; obj != NULL; obj = obj->next_content)
act_info.c:			pdesc = get_extra_descr (arg3, obj->extra_descr);
act_info.c:			pdesc = get_extra_descr (arg3, obj->pIndexData->extra_descr);
act_info.c:			if (is_name (arg3, obj->name))
act_info.c:					if (obj->item_type == ITEM_WRITING_PAPER)
act_info.c:							obj->extra_descr)) == NULL)
act_info.c:					else if (obj->item_type == ITEM_MAP)
act_info.c:							obj->extra_descr)) == NULL)
act_info.c:					send_to_char (obj->description, ch);
act_info.c:	for (obj = ch->in_room->contents; obj != NULL; obj = obj->next_content)
act_info.c:			pdesc = get_extra_descr (arg3, obj->extra_descr);
act_info.c:				pdesc = get_extra_descr (arg3, obj->pIndexData->extra_descr);
act_info.c:		if (is_name (arg3, obj->name))
act_info.c:				if (obj->pIndexData->vnum == OBJ_VNUM_CLAN_SYMBOL)
act_info.c:					sprintf (buf, obj->description,
act_info.c:					if (obj->description[0] != '\0')
act_info.c:						strcpy (buf, obj->description);
act_info.c:		switch (obj->item_type)
act_info.c:			if (obj->value[0] == 0)
act_info.c:				if (obj->value[1] == 0)
act_info.c:				else if (obj->value[1] == 1)
act_info.c:					obj->value[1]);
act_info.c:			else if (obj->value[1] == 0)
act_info.c:				if (obj->value[0] == 1)
act_info.c:					obj->value[0]);
act_info.c:				obj->value[1], obj->value[0]);
act_info.c:		for (obj = theroom->contents; obj; obj = obj->next_content)
act_info.c:			if (obj->item_type != ITEM_PORTAL
act_info.c:				&& obj->item_type != ITEM_ELEVATOR
act_info.c:				&& obj->item_type != ITEM_CTRANSPORT)
act_info.c:			if (obj->item_type == ITEM_CTRANSPORT
act_info.c:				&& IS_SET (obj->value[5], CONT_CLOSED))
act_info.c:			if (obj->item_type == ITEM_PORTAL
act_info.c:				&& !IS_SET (obj->value[2], GATE_SHOWEXIT))
act_info.c:			strcpy (onename, obj->name);
act_info.c:			if (obj->item_type == ITEM_PORTAL)
act_info.c:				room_vnum = obj->value[3];
act_info.c:			else if (obj->item_type == ITEM_ELEVATOR)
act_info.c:				room_vnum = obj->value[0];
act_info.c:				room_vnum = obj->value[2];
act_info.c:			if (((obj->item_type
act_info.c:				== ITEM_PORTAL && IS_SET (obj->value[4], PACT_ENTER))
act_info.c:				|| obj->item_type == ITEM_ELEVATOR
act_info.c:				|| obj->item_type == ITEM_CTRANSPORT) && !fCar)
act_info.c:					if (obj->item_type == ITEM_CTRANSPORT &&
act_info.c:						(IS_SET (obj->value[4], TACT_SAIL)
act_info.c:						|| IS_SET (obj->value[4], TACT_PADDLE)
act_info.c:						|| IS_SET (obj->value[4], TACT_ROW)))
act_info.c:					if (obj->item_type == ITEM_CTRANSPORT &&
act_info.c:						(IS_SET (obj->value[4], TACT_SAIL)
act_info.c:						|| IS_SET (obj->value[4], TACT_PADDLE)
act_info.c:						|| IS_SET (obj->value[4], TACT_ROW)))
act_info.c:			if (obj->item_type == ITEM_PORTAL
act_info.c:				&& IS_SET (obj->value[4], PACT_EXIT))
act_info.c:			if (obj->item_type == ITEM_PORTAL
act_info.c:				&& IS_SET (obj->value[4], PACT_JUMP))
act_info.c:			if (obj->item_type == ITEM_PORTAL
act_info.c:				&& IS_SET (obj->value[4], PACT_CLIMB))
act_info.c:			if (obj->item_type == ITEM_PORTAL
act_info.c:				&& IS_SET (obj->value[4], PACT_PLAY))
act_info.c:			if (obj->item_type == ITEM_PORTAL
act_info.c:				&& IS_SET (obj->value[4], PACT_DESCEND))
act_info.c:			if (obj->item_type == ITEM_PORTAL
act_info.c:				&& IS_SET (obj->value[4], PACT_CRAWL))
act_info.c:			if (obj->item_type == ITEM_PORTAL
act_info.c:				&& IS_SET (obj->value[4], PACT_SCALE))
act_info.c:			&& IS_SET(obj->wear_flags,ITEM_WEAR_ANOTHER_WRIST))
act_info.c:			&& IS_SET(obj->wear_flags,ITEM_WEAR_ANOTHER_FINGER))
act_info.c:			&& IS_SET(obj->wear_flags,ITEM_WEAR_ANOTHER_NECK))
act_info.c:			&&  IS_SET(obj->wear_loc,ITEM_TWO_HANDS))
act_info.c:			if (!IS_SET(obj->wear_loc,wear_conversion_table[k].wear_flag))
act_info.c:				&& IS_SET(obj->wear_flags,ITEM_WEAR_ANOTHER_WRIST))
act_info.c:				&& IS_SET(obj->wear_flags,ITEM_WEAR_ANOTHER_FINGER))
act_info.c:				&& IS_SET(obj->wear_flags,ITEM_WEAR_ANOTHER_NECK))
act_info.c:				&& IS_SET(obj->wear_loc,ITEM_TWO_HANDS))
act_info.c:	for (obj = ch->carrying; obj != NULL; obj = obj->next_content)
act_info.c:			if (is_name (arg, obj->name))
act_info.c:		act(obj->description,ch,NULL,NULL,TO_ROOM);
act_info.c:		//    send_to_char(obj->description,victim);
act_info.c:		if (obj->item_type == ITEM_CARD)
act_info.c:		send_to_char(obj->description,victim);
act_info.c:		if (obj->item_type == ITEM_CARD)
act_move.c:  for (obj = ch->in_room->contents; obj; obj = obj->next_content)
act_move.c:    if (obj->pIndexData->vnum == OBJ_VNUM_CAMPFIRE1
act_move.c:	|| obj->pIndexData->vnum == OBJ_VNUM_CAMPFIRE2
act_move.c:	|| obj->pIndexData->vnum == OBJ_VNUM_CAMPFIRE3)
act_move.c:  if ((obj->value[0] != WEAPON_SWORD) &&
act_move.c:      (obj->value[0] != WEAPON_AXE) &&
act_move.c:      (obj->value[0] != WEAPON_DAGGER) &&
act_move.c:      (obj->value[0] != WEAPON_POLEARM) && (obj->value[0] != WEAPON_ARROW))
act_move.c:  if (obj->condition == 0)
act_move.c:    obj->condition = 100;
act_move.c:  damage = (obj->condition - (125 - hone_skill));
act_move.c:      if ((str_cmp (obj->material, "steel") == 0) ||
act_move.c:	  (str_cmp (obj->material, "iron") == 0) ||
act_move.c:	  (str_cmp (obj->material, "metal") == 0) ||
act_move.c:	  (str_cmp (obj->material, "adamantite") == 0) ||
act_move.c:	  (str_cmp (obj->material, "platinum") == 0) ||
act_move.c:	  (str_cmp (obj->material, "silver") == 0) ||
act_move.c:	  (str_cmp (obj->material, "bronze") == 0) ||
act_move.c:	  (str_cmp (obj->material, "brass") == 0) ||
act_move.c:	  (str_cmp (obj->material, "copper") == 0))
act_move.c:		    obj->condition -= (125 - hone_skill);
act_move.c:		    obj->condition -= (135 - hone_skill);
act_move.c:      if (str_cmp (obj->material, "wood") == 0)
act_move.c:		if (obj->value[4] & WEAPON_POISON)
act_move.c:		    obj->value[4] = obj->value[4] & !WEAPON_POISON;
act_move.c:		    for (paf = obj->affected; paf != NULL; paf = paf_next)
act_move.c:		    obj->condition -= (125 - hone_skill);
act_move.c:		    obj->condition -= (135 - hone_skill);
act_move.c:			obj->timer = 3;
act_move.c:  for (obj = ch->in_room->contents; obj; obj = obj->next_content)
act_move.c:    if (obj->pIndexData->vnum == OBJ_VNUM_CAMPFIRE1
act_move.c:	|| obj->pIndexData->vnum == OBJ_VNUM_CAMPFIRE2
act_move.c:	|| obj->pIndexData->vnum == OBJ_VNUM_CAMPFIRE3)
act_move.c:  obj->level = ch->level;
act_move.c:  obj->timer = ch->level / 8;
act_move.c:  if (obj->timer < 1)
act_move.c:    obj->timer = 1;
act_move.c:	    obj_next = obj->next_content;
act_move.c:	    if (obj->pIndexData->vnum == OBJ_VNUM_ATICKET)
act_move.c:	    obj_next = obj->next_content;
act_move.c:	    if (obj->pIndexData->vnum == OBJ_VNUM_ZTICKET)
act_move.c:	      for (obj = ch->carrying; obj != NULL; obj = obj->next_content)
act_move.c:		  if (obj->item_type == ITEM_GILLS
act_move.c:		      && obj->wear_loc != WEAR_NONE)
act_move.c:	    for (obj = ch->carrying; obj != NULL; obj = obj->next_content)
act_move.c:		if (obj->item_type == ITEM_GILLS
act_move.c:		    && obj->wear_loc != WEAR_NONE)
act_move.c:	  obj->timer = 1;
act_move.c:          sprintf (tcbuf, obj->description, dir_name[door]);
act_move.c:          free_string (obj->description);
act_move.c:          obj->description = str_dup (tcbuf);
act_move.c:    obj->timer = 1;
act_move.c:    free_string (obj->description);
act_move.c:    obj->description = str_dup (tcbuf);
act_move.c:    free_string (obj->short_descr);
act_move.c:    obj->short_descr = str_dup (tcbuf);
act_move.c:    obj->value[0] = 1;
act_move.c:      if (obj->item_type != ITEM_CTRANSPORT)
act_move.c:      if (!IS_SET (obj->value[5], CONT_CLOSED))
act_move.c:      location = get_room_index (obj->value[2]);
act_move.c:      if (IS_SET (obj->value[5], CONT_NOBASH)
act_move.c:	  REMOVE_BIT (obj->value[5], CONT_CLOSEABLE);
act_move.c:	  REMOVE_BIT (obj->value[5], CONT_CLOSED);
act_move.c:	  REMOVE_BIT (obj->value[5], CONT_LOCKED);
act_move.c:      if (obj->item_type == ITEM_PORTAL)
act_move.c:	  if (!IS_SET (obj->value[1], EX_ISDOOR))
act_move.c:	  if (!IS_SET (obj->value[1], EX_CLOSED))
act_move.c:	  if (IS_SET (obj->value[1], EX_LOCKED))
act_move.c:	  REMOVE_BIT (obj->value[1], EX_CLOSED);
act_move.c:      if (obj->item_type == ITEM_CTRANSPORT)
act_move.c:	  if (!IS_SET (obj->value[5], CONT_CLOSED))
act_move.c:	  if (!IS_SET (obj->value[5], CONT_CLOSEABLE))
act_move.c:	  if (IS_SET (obj->value[5], CONT_LOCKED))
act_move.c:	  REMOVE_BIT (obj->value[5], CONT_CLOSED);
act_move.c:      if (obj->item_type != ITEM_CONTAINER
act_move.c:	  && obj->item_type != ITEM_PACK && obj->item_type != ITEM_QUIVER)
act_move.c:      if (!IS_SET (obj->value[1], CONT_CLOSED))
act_move.c:      if (!IS_SET (obj->value[1], CONT_CLOSEABLE))
act_move.c:      if (IS_SET (obj->value[1], CONT_LOCKED))
act_move.c:      REMOVE_BIT (obj->value[1], CONT_CLOSED);
act_move.c:      for (obj = object_list; obj; obj = obj->next)
act_move.c:	  if (obj->item_type != ITEM_CTRANSPORT)
act_move.c:	  if (obj->value[2] == ch->in_room->vnum && is_name (arg, obj->name))
act_move.c:	      if (!IS_SET (obj->value[5], CONT_CLOSED))
act_move.c:	      if (!IS_SET (obj->value[5], CONT_CLOSEABLE))
act_move.c:	      if (IS_SET (obj->value[5], CONT_LOCKED))
act_move.c:	      REMOVE_BIT (obj->value[5], CONT_CLOSED);
act_move.c:      if (obj->item_type == ITEM_PORTAL)
act_move.c:	  if (!IS_SET (obj->value[1], EX_ISDOOR)
act_move.c:	      || IS_SET (obj->value[1], EX_NOCLOSE))
act_move.c:	  if (IS_SET (obj->value[1], EX_CLOSED))
act_move.c:	  SET_BIT (obj->value[1], EX_CLOSED);
act_move.c:      if (obj->item_type == ITEM_CTRANSPORT)
act_move.c:	  if (IS_SET (obj->value[5], CONT_CLOSED))
act_move.c:	  if (!IS_SET (obj->value[5], CONT_CLOSEABLE))
act_move.c:	  SET_BIT (obj->value[5], CONT_CLOSED);
act_move.c:      if (obj->item_type != ITEM_CONTAINER
act_move.c:	  && obj->item_type != ITEM_PACK && obj->item_type
act_move.c:	  && obj->item_type != ITEM_QUIVER)
act_move.c:      if (IS_SET (obj->value[1], CONT_CLOSED))
act_move.c:      if (!IS_SET (obj->value[1], CONT_CLOSEABLE))
act_move.c:      SET_BIT (obj->value[1], CONT_CLOSED);
act_move.c:      for (obj = object_list; obj; obj = obj->next)
act_move.c:	  if (obj->item_type != ITEM_CTRANSPORT)
act_move.c:	  if (obj->value[2] == ch->in_room->vnum && is_name (arg, obj->name))
act_move.c:	      if (IS_SET (obj->value[5], CONT_CLOSED))
act_move.c:	      if (!IS_SET (obj->value[5], CONT_CLOSEABLE))
act_move.c:	      SET_BIT (obj->value[5], CONT_CLOSED);
act_move.c:  for (obj = ch->carrying; obj != NULL; obj = obj->next_content)
act_move.c:      if (obj->pIndexData->vnum == key)
act_move.c:  for (obj = ch->carrying; obj != NULL; obj = obj->next_content)
act_move.c:      if (obj->pIndexData->vnum == tObj->value[6]
act_move.c:	  && !str_cmp (obj->owner, tObj->owner))
act_move.c:      if (obj->item_type == ITEM_PORTAL)
act_move.c:	  if (!IS_SET (obj->value[1], EX_ISDOOR)
act_move.c:	      || IS_SET (obj->value[1], EX_NOCLOSE))
act_move.c:	  if (!IS_SET (obj->value[1], EX_CLOSED))
act_move.c:	  if (obj->value[4] < 0 || IS_SET (obj->value[1], EX_NOLOCK))
act_move.c:	  if (!has_key (ch, obj->value[4]))
act_move.c:	  if (IS_SET (obj->value[1], EX_LOCKED))
act_move.c:	  SET_BIT (obj->value[1], EX_LOCKED);
act_move.c:	    for (kobj = ch->carrying; kobj != NULL; kobj = kobj->next_content)
act_move.c:		if (kobj->pIndexData->vnum == obj->value[4])
act_move.c:		    if (kobj->item_type == ITEM_ROOM_KEY)
act_move.c:		      kobj->value[0]++;
act_move.c:		    if (kobj->value[0] >= 2)
act_move.c:      if (obj->item_type == ITEM_CTRANSPORT)
act_move.c:	  if (!IS_SET (obj->value[5], CONT_CLOSED))
act_move.c:	  if (obj->value[5] < 0)
act_move.c:	  if (!has_key (ch, obj->value[6]))
act_move.c:	  if (IS_SET (obj->value[5], CONT_LOCKED))
act_move.c:	  SET_BIT (obj->value[5], CONT_LOCKED);
act_move.c:      if (obj->item_type != ITEM_CONTAINER)
act_move.c:      if (!IS_SET (obj->value[1], CONT_CLOSED))
act_move.c:      if (obj->value[2] < 0)
act_move.c:      if (!has_key (ch, obj->value[2]))
act_move.c:      if (IS_SET (obj->value[1], CONT_LOCKED))
act_move.c:      SET_BIT (obj->value[1], CONT_LOCKED);
act_move.c:	for (kobj = ch->carrying; kobj != NULL; kobj = kobj->next_content)
act_move.c:	    if (kobj->pIndexData->vnum == obj->value[2])
act_move.c:		if (kobj->item_type == ITEM_ROOM_KEY)
act_move.c:		  kobj->value[0]++;
act_move.c:		if (kobj->value[0] >= 2)
act_move.c:      for (obj = object_list; obj; obj = obj->next)
act_move.c:	  if (obj->item_type != ITEM_CTRANSPORT)
act_move.c:	  if (obj->value[2] == ch->in_room->vnum && is_name (arg, obj->name))
act_move.c:	      if (!IS_SET (obj->value[5], CONT_CLOSED))
act_move.c:	      if (obj->value[5] < 0)
act_move.c:	      if (!has_key (ch, obj->value[6]))
act_move.c:	      if (IS_SET (obj->value[5], CONT_LOCKED))
act_move.c:	      SET_BIT (obj->value[5], CONT_LOCKED);
act_move.c:	for (kobj = ch->carrying; kobj != NULL; kobj = kobj->next_content)
act_move.c:	    if (kobj->pIndexData->vnum == pexit->key)
act_move.c:		if (kobj->item_type == ITEM_ROOM_KEY)
act_move.c:		  kobj->value[0]++;
act_move.c:		if (kobj->value[0] >= 2)
act_move.c:      if (obj->item_type == ITEM_PORTAL)
act_move.c:	  if (IS_SET (obj->value[1], EX_ISDOOR))
act_move.c:	  if (!IS_SET (obj->value[1], EX_CLOSED))
act_move.c:	  if (obj->value[4] < 0)
act_move.c:	  if (!has_key (ch, obj->value[4]))
act_move.c:	  if (!IS_SET (obj->value[1], EX_LOCKED))
act_move.c:	  REMOVE_BIT (obj->value[1], EX_LOCKED);
act_move.c:	    for (kobj = ch->carrying; kobj != NULL; kobj = kobj->next_content)
act_move.c:		if (kobj->pIndexData->vnum == obj->value[4])
act_move.c:		    if (kobj->item_type == ITEM_ROOM_KEY)
act_move.c:		      kobj->value[0]++;
act_move.c:		    if (kobj->value[0] >= 2)
act_move.c:      if (obj->item_type == ITEM_CTRANSPORT)
act_move.c:	  if (!IS_SET (obj->value[5], CONT_CLOSED))
act_move.c:	  if (obj->value[5] < 0)
act_move.c:	  if (!IS_SET (obj->value[5], CONT_LOCKED))
act_move.c:	  REMOVE_BIT (obj->value[5], CONT_LOCKED);
act_move.c:      if (obj->item_type != ITEM_CONTAINER)
act_move.c:      if (!IS_SET (obj->value[1], CONT_CLOSED))
act_move.c:      if (obj->value[2] < 0)
act_move.c:      if (!has_key (ch, obj->value[2]))
act_move.c:      if (!IS_SET (obj->value[1], CONT_LOCKED))
act_move.c:      REMOVE_BIT (obj->value[1], CONT_LOCKED);
act_move.c:	for (kobj = ch->carrying; kobj != NULL; kobj = kobj->next_content)
act_move.c:	    if (kobj->pIndexData->vnum == obj->value[2])
act_move.c:		if (kobj->item_type == ITEM_ROOM_KEY)
act_move.c:		  kobj->value[0]++;
act_move.c:		if (kobj->value[0] >= 2)
act_move.c:      for (obj = object_list; obj; obj = obj->next)
act_move.c:	  if (obj->item_type != ITEM_CTRANSPORT)
act_move.c:	  if (obj->value[2] == ch->in_room->vnum && is_name (arg, obj->name))
act_move.c:	      if (!IS_SET (obj->value[5], CONT_CLOSED))
act_move.c:	      if (obj->value[5] < 0)
act_move.c:	      if (!IS_SET (obj->value[5], CONT_LOCKED))
act_move.c:	      REMOVE_BIT (obj->value[5], CONT_LOCKED);
act_move.c:	for (kobj = ch->carrying; kobj != NULL; kobj = kobj->next_content)
act_move.c:	    if (kobj->pIndexData->vnum == pexit->key)
act_move.c:		if (kobj->item_type == ITEM_ROOM_KEY)
act_move.c:		  kobj->value[0]++;
act_move.c:		if (kobj->value[0] >= 2)
act_move.c:      if (obj->item_type == ITEM_PORTAL)
act_move.c:	  if (!IS_SET (obj->value[1], EX_ISDOOR))
act_move.c:	  if (!IS_SET (obj->value[1], EX_CLOSED))
act_move.c:	  if (obj->value[4] < 0)
act_move.c:	  if (IS_SET (obj->value[1], EX_PICKPROOF))
act_move.c:	  REMOVE_BIT (obj->value[1], EX_LOCKED);
act_move.c:      if (obj->item_type != ITEM_CONTAINER)
act_move.c:      if (!IS_SET (obj->value[1], CONT_CLOSED))
act_move.c:      if (obj->value[2] < 0)
act_move.c:      if (!IS_SET (obj->value[1], CONT_LOCKED))
act_move.c:      if (IS_SET (obj->value[1], CONT_PICKPROOF))
act_move.c:      REMOVE_BIT (obj->value[1], CONT_LOCKED);
act_move.c:      if ((obj->item_type != ITEM_FURNITURE && obj->item_type != ITEM_RAFT)
act_move.c:	  || (!IS_SET (obj->value[2], STAND_AT)
act_move.c:	      && !IS_SET (obj->value[2], STAND_ON)
act_move.c:	      && !IS_SET (obj->value[2], STAND_IN)))
act_move.c:      if (ch->on != obj && count_users (obj) >= obj->value[0])
act_move.c:      else if (IS_SET (obj->value[2], STAND_AT))
act_move.c:      else if (IS_SET (obj->value[2], STAND_ON))
act_move.c:	  if (obj->pIndexData->vnum == OBJ_VNUM_HEXAGRAM)
act_move.c:      else if (IS_SET (obj->value[2], STAND_AT))
act_move.c:      else if (IS_SET (obj->value[2], STAND_ON))
act_move.c:	  if (obj->pIndexData->vnum == OBJ_VNUM_HEXAGRAM)
act_move.c:      else if (IS_SET (obj->value[2], STAND_AT))
act_move.c:      else if (IS_SET (obj->value[2], STAND_ON))
act_move.c:	  if (obj->pIndexData->vnum == OBJ_VNUM_HEXAGRAM)
act_move.c:      if ((!IS_SET (obj->item_type, ITEM_FURNITURE) && !IS_SET(obj->item_type,ITEM_RAFT))
act_move.c:	  || (!IS_SET (obj->value[2], REST_ON)
act_move.c:	      && !IS_SET (obj->value[2], REST_IN)
act_move.c:	      && !IS_SET (obj->value[2], REST_AT)))
act_move.c:      if (obj != NULL && ch->on != obj && count_users (obj) >= obj->value[0])
act_move.c:      else if (IS_SET (obj->value[2], REST_AT))
act_move.c:      else if (IS_SET (obj->value[2], REST_ON))
act_move.c:      else if (IS_SET (obj->value[2], REST_AT))
act_move.c:      else if (IS_SET (obj->value[2], REST_ON))
act_move.c:      else if (IS_SET (obj->value[2], REST_AT))
act_move.c:      else if (IS_SET (obj->value[2], REST_ON))
act_move.c:      if ((!IS_SET (obj->item_type, ITEM_FURNITURE) && !IS_SET (obj->item_type,ITEM_RAFT))
act_move.c:	  || (!IS_SET (obj->value[2], SIT_ON)
act_move.c:	      && !IS_SET (obj->value[2], SIT_IN)
act_move.c:	      && !IS_SET (obj->value[2], SIT_AT)))
act_move.c:      if (obj != NULL && ch->on != obj && count_users (obj) >= obj->value[0])
act_move.c:      else if (IS_SET (obj->value[2], SIT_AT))
act_move.c:      else if (IS_SET (obj->value[2], SIT_ON))
act_move.c:      else if (IS_SET (obj->value[2], SIT_AT))
act_move.c:      else if (IS_SET (obj->value[2], SIT_ON))
act_move.c:      else if (IS_SET (obj->value[2], SIT_AT))
act_move.c:      else if (IS_SET (obj->value[2], SIT_ON))
act_move.c:	  if ((obj->item_type != ITEM_FURNITURE && obj->item_type != ITEM_RAFT)
act_move.c:	      || (!IS_SET (obj->value[2], SLEEP_ON)
act_move.c:		  && !IS_SET (obj->value[2], SLEEP_IN)
act_move.c:		  && !IS_SET (obj->value[2], SLEEP_AT)))
act_move.c:	  if (ch->on != obj && count_users (obj) >= obj->value[0])
act_move.c:	  if (IS_SET (obj->value[2], SLEEP_AT))
act_move.c:	  else if (IS_SET (obj->value[2], SLEEP_ON))
act_move.c:	    obj_next = obj->next_content;
act_move.c:	    if (obj->pIndexData->vnum == OBJ_VNUM_ATICKET)
act_move.c:	    obj_next = obj->next_content;
act_move.c:	    if (obj->pIndexData->vnum == OBJ_VNUM_ZTICKET)
act_move.c:	     for (obj = ch->carrying; obj != NULL; obj = obj->next_content)
act_move.c:		 if (obj->item_type == ITEM_GILLS
act_move.c:		     && obj->wear_loc != WEAR_NONE)
act_move.c:	      for (obj = ch->carrying; obj != NULL; obj = obj->next_content)
act_move.c:		  if (obj->item_type == ITEM_GILLS
act_move.c:		      && obj->wear_loc != WEAR_NONE)
act_move.c:      obj->timer = 24;
act_move.c:      obj->value[1] = ch->in_room->sector_type;
act_move.c:      obj->value[0] = ch->in_room->vnum;
act_obj.c:      if (!str_cmp (obj_walk->short_descr, obj->short_descr))
act_obj.c:	  obj->next_content = obj_walk->next_content;
act_obj.c:	  last_obj->next_content = obj;
act_obj.c:	  obj->next_content = NULL;
act_obj.c:	  obj->next_content = NULL;
act_obj.c:  obj->in_obj = shelf;
act_obj.c:  obj->in_room = NULL;
act_obj.c:  obj->carried_by = NULL;
act_obj.c:  if (IS_SET (obj->extra_flags[0], ITEM_PERMSTOCK))
act_obj.c:  if (IS_SET (obj->extra_flags[0], ITEM_DONATE))
act_obj.c:    obj->cost = 0;
act_obj.c:    obj->cost = obj->pIndexData->cost;
act_obj.c:  sprintf(arg1,"%s UNstocked %s in their store at %d.",ch->name,obj->short_descr,ch->in_room->vnum);
act_obj.c:  if (IS_OBJ_STAT (obj, ITEM_NOSAVE) || IS_SET(obj->extra_flags[1],ITEM_NOSTOCK))
act_obj.c:  if (obj->item_type == ITEM_KEY && !obj->value[0])
act_obj.c:  if (obj->contains != NULL)
act_obj.c:    obj->cost = cost;
act_obj.c:  if (obj->cost == 0)
act_obj.c:    obj->cost = 1;
act_obj.c:  if (IS_SET (obj->extra_flags[0], ITEM_PERMSTOCK))
act_obj.c:    REMOVE_BIT (obj->extra_flags[0], ITEM_PERMSTOCK);
act_obj.c:  sprintf(arg1,"%s stocked %s for %d in their store at %d.",ch->name,obj->short_descr,obj->cost,ch->in_room->vnum);
act_obj.c:  if (obj->wear_loc != -1)
act_obj.c:  if (IS_OBJ_STAT (obj, ITEM_NOSAVE) || IS_SET(obj->extra_flags[1],ITEM_NODONATE) 
act_obj.c:		  || obj->item_type == ITEM_CARD)
act_obj.c:  if (obj->pIndexData->vnum >= 23000 && obj->pIndexData->vnum <= 23100)
act_obj.c:  SET_BIT (obj->extra_flags[0], ITEM_DONATE);
act_obj.c:  obj->cost = 0;
act_obj.c:      for (obj = ch->in_room->contents; obj; obj = obj->next_content)
act_obj.c:	if (obj->pIndexData->vnum == OBJ_VNUM_WALL_THORNS
act_obj.c:	    && obj->value[0] == dir_num)
act_obj.c:	  sprintf (buf, obj->description, dir_name[dir_num]);
act_obj.c:	  free_string (obj->description);
act_obj.c:	  obj->description = str_dup (buf);
act_obj.c:	  obj->value[0] = dir_num;
act_obj.c:	  obj->timer = (ch->level / 10);
act_obj.c:	  obj->level = ch->level;
act_obj.c:  if (write_obj->item_type != ITEM_WRITING_INSTRUMENT)
act_obj.c:  if (obj->item_type != ITEM_WRITING_PAPER)
act_obj.c:  for (ed = obj->extra_descr; ed != NULL; ed = ed->next)
act_obj.c:      ed->next = obj->extra_descr;
act_obj.c:      obj->extra_descr = ed;
act_obj.c:  if ((obj->pIndexData->vnum >= OBJ_VNUM_ASHIELD
act_obj.c:      && obj->pIndexData->vnum <= OBJ_VNUM_AINST) || IS_SET(obj->extra_flags[1],ITEM_NOAUCTION))
act_obj.c:  if (obj->wear_loc != -1)
act_obj.c:    switch (obj->item_type)
act_obj.c:	if (obj->timer > 0)
act_obj.c:	if (obj->contains != NULL)
act_obj.c:		     obj->short_descr);
act_obj.c:		     obj->short_descr);
act_obj.c:  for (obj = ch->in_room->contents; obj; obj = obj->next_content)
act_obj.c:    if (obj->pIndexData->vnum == OBJ_VNUM_TRIPWIRE)
act_obj.c:  if (!obj->owner || obj->owner == NULL)
act_obj.c:    if (!str_cmp (wch->name, obj->owner))
act_obj.c:  if (IS_SET(obj->extra_flags[0],ITEM_NOMOB) && IS_NPC(ch))
act_obj.c:  if (obj->plr_owner != NULL)
act_obj.c:    if (str_cmp (ch->name, obj->plr_owner) && !IS_IMMORTAL(ch))
act_obj.c:	sprintf (buf, "You do not own %s!\n\r", obj->short_descr);
act_obj.c:      act ("$d: you can't carry that many items.", ch, NULL, obj->name,
act_obj.c:  if (obj->item_type == ITEM_QUIVER && has_quiver (ch))
act_obj.c:  if (obj->item_type == ITEM_PORTAL)
act_obj.c:  if ((!obj->in_obj || obj->in_obj->carried_by != ch)
act_obj.c:      act ("$d: you can't carry that much weight.", ch, NULL, obj->name,
act_obj.c:		 NULL, obj->name, TO_CHAR);
act_obj.c:  if (obj->in_room != NULL)
act_obj.c:      for (gch = obj->in_room->people; gch != NULL; gch = gch->next_in_room)
act_obj.c:	  && get_trust (ch) < obj->level - 10)
act_obj.c:	obj->timer = 0;
act_obj.c:      REMOVE_BIT (obj->extra_flags[0], ITEM_HAD_TIMER);
act_obj.c:      cntr = obj->in_obj;
act_obj.c:	  && obj->item_type == ITEM_WEAPON && obj->value[0] == WEAPON_ARROW)
act_obj.c:  if (obj->item_type == ITEM_MONEY)
act_obj.c:      ch->silver += obj->value[0];
act_obj.c:      ch->gold += obj->value[1];
act_obj.c:	  if (members > 1 && (obj->value[0] > 1 || obj->value[1]))
act_obj.c:	      sprintf (buffer, "%d %d", obj->value[0], obj->value[1]);
act_obj.c:      if (obj != NULL && obj->pIndexData->vnum == OBJ_VNUM_CORPSE_PC)
act_obj.c:	      obj_next = obj->next_content;
act_obj.c:	      switch (obj->pIndexData->vnum)
act_obj.c:		  silver += obj->value[0];
act_obj.c:		  gold += obj->value[1];
act_obj.c:		  silver += obj->value[0];
act_obj.c:		  gold += obj->value[1];
act_obj.c:	      obj_next = obj->next_content;
act_obj.c:	      if ((arg[3] == '\0' || is_name (&arg[4], obj->name))
act_obj.c:		  && obj->wear_loc == WEAR_NONE && can_drop_obj (ch, obj))
act_obj.c:      if (obj->wear_loc != WEAR_NONE)
act_obj.c:      if (IS_NPC(victim) && IS_SET(obj->extra_flags[0],ITEM_NOMOB))
act_obj.c:      if (obj->item_type == ITEM_QUIVER && has_quiver (victim))
act_obj.c:      if (obj->item_type == ITEM_PORTAL)
act_obj.c:  if (IS_SET(obj->extra_flags[0],ITEM_NOMOB) && IS_NPC(ch))
act_obj.c:  if (obj->plr_owner != NULL)
act_obj.c:	  if (str_cmp (ch->name, obj->plr_owner) && !IS_IMMORTAL(ch))
act_obj.c:		  sprintf (buf, "You do not own %s!\n\r", obj->short_descr);
act_obj.c:      act ("$d: you can't carry that many items.", ch, NULL, obj->name,
act_obj.c:  if (obj->item_type == ITEM_PORTAL)
act_obj.c:      act ("$d: you can't carry that much weight.", ch, NULL, obj->name,
act_obj.c:  if (obj->in_room != NULL)
act_obj.c:      for (gch = obj->in_room->people; gch != NULL; gch = gch->next_in_room)
act_obj.c:  if (obj->item_type == ITEM_MONEY)
act_obj.c:      ch->silver += obj->value[0];
act_obj.c:      ch->gold += obj->value[1];
act_obj.c:	  if (members > 1 && (obj->value[0] > 1 || obj->value[1]))
act_obj.c:	      sprintf (buffer, "%d %d", obj->value[0], obj->value[1]);
act_obj.c:      if (obj != NULL && obj->pIndexData->vnum == OBJ_VNUM_CORPSE_PC)
act_obj.c:	      obj_next = obj->next_content;
act_obj.c:	      if ((arg1[3] == '\0' || is_name (&arg1[4], obj->name))
act_obj.c:	for (obj = ch->in_room->contents; obj != NULL; obj = obj->next)
act_obj.c:	  if (obj->pIndexData->vnum <= 5 && obj->pIndexData->vnum >= 1)
act_obj.c:	    switch (obj->pIndexData->vnum)
act_obj.c:	       if ((amount = atoi(arg1)) > obj->value[0] || !str_prefix(arg2,"gold"))
act_obj.c:	       if (amount >= obj->value[0])
act_obj.c:	       else obj->value[0] -= amount;
act_obj.c:		if ((amount = atoi(arg1)) > obj->value[1] || str_prefix(arg2,"gold"))
act_obj.c:		if (amount >= obj->value[1])
act_obj.c:		else obj->value[1] -= amount;
act_obj.c:                if (((amount = atoi(arg1)) > obj->value[1] && !str_prefix(arg2,"gold"))
act_obj.c:		    || ((amount = atoi(arg1)) > obj->value[0] && str_prefix(arg2,"gold")) )
act_obj.c:		    obj->value[1] -= amount;
act_obj.c:		    obj->value[0] -= amount;
act_obj.c:		    if (obj->value[0] == 0 && obj->value[1] == 0)
act_obj.c:		    else /*if ((obj->value[0] == 1 && obj->value[1] == 0) //1 silver left
act_obj.c:			|| (obj->value[0] == 0 && obj->value[1] == 1) //1 gold left
act_obj.c:			|| (obj->value[0] == 0 && obj->value[1] >= 1) //some gold left
act_obj.c:			|| (obj->value[0] >= 1 && obj->value[1] == 0)) //some silver left*/
act_obj.c:			      silver = obj->value[0];
act_obj.c:			      gold = obj->value[1];
act_obj.c:	      obj_next = obj->next_content;
act_obj.c:	      if ((arg1[3] == '\0' || is_name (&arg1[4], obj->name))
act_obj.c:	  obj_next = obj->next_content;
act_obj.c:	  if ((arg1[3] == '\0' || is_name (&arg1[4], obj->name))
act_obj.c:      if (obj->item_type != ITEM_SADDLE && obj->item_type != ITEM_PACK)
act_obj.c:      if (obj->item_type == ITEM_PACK
act_obj.c:      if (obj->item_type == ITEM_SADDLE
act_obj.c:      if (obj->item_type == ITEM_PACK)
act_obj.c:      if (WEIGHT_MULT (obj) != 100 || obj->item_type == ITEM_QUIVER || WEIGHT_MULTP (obj) != 100)
act_obj.c:	  if (obj->item_type != ITEM_WEAPON || obj->value[0] != WEAPON_ARROW)
act_obj.c:	  if (obj->timer)
act_obj.c:	    SET_BIT (obj->extra_flags[0], ITEM_HAD_TIMER);
act_obj.c:	    obj->timer = number_range (100, 200);
act_obj.c:	  obj_next = obj->next_content;
act_obj.c:	  if ((arg1[3] == '\0' || is_name (&arg1[4], obj->name))
act_obj.c:	      && obj->item_type != ITEM_QUIVER && obj->wear_loc ==
act_obj.c:							  && obj->
act_obj.c:							  && obj->
act_obj.c:		  if (obj->timer)
act_obj.c:		    SET_BIT (obj->extra_flags[0], ITEM_HAD_TIMER);
act_obj.c:		    obj->timer = number_range (100, 200);
act_obj.c:	  if (obj->timer)
act_obj.c:	    SET_BIT (obj->extra_flags[0], ITEM_HAD_TIMER);
act_obj.c:	    obj->timer = number_range (100, 200);
act_obj.c:	  obj_next = obj->next_content;
act_obj.c:	  if ((arg1[3] == '\0' || is_name (&arg1[4], obj->name))
act_obj.c:	      && obj->wear_loc == WEAR_NONE
act_obj.c:		  if (obj->timer)
act_obj.c:		    SET_BIT (obj->extra_flags[0], ITEM_HAD_TIMER);
act_obj.c:		    obj->timer = number_range (100, 200);
act_obj.c:	  obj_next = obj->next_content;
act_obj.c:	  switch (obj->pIndexData->vnum)
act_obj.c:	      silver += obj->value[0];
act_obj.c:	      gold += obj->value[1];
act_obj.c:	      silver += obj->value[0];
act_obj.c:	      gold += obj->value[1];
act_obj.c:	  obj_next = obj->next_content;
act_obj.c:	  if ((arg[3] == '\0' || is_name (&arg[4], obj->name))
act_obj.c:	      && obj->wear_loc == WEAR_NONE && can_drop_obj (ch, obj))
act_obj.c:  if (obj->wear_loc != WEAR_NONE)
act_obj.c:  if (obj->item_type == ITEM_QUIVER && has_quiver (victim))
act_obj.c:  if (IS_NPC(victim) && IS_SET(obj->extra_flags[0],ITEM_NOMOB))
act_obj.c:  if (obj->item_type == ITEM_PORTAL)
act_obj.c:	      act_trigger (victim, pTrig->name, obj->name, NAME (ch),
act_obj.c:  if (obj->item_type == ITEM_FOOD || obj->item_type == ITEM_DRINK_CON)
act_obj.c:	  if (!obj->value[3])
act_obj.c:	      obj->value[3] = 1;
act_obj.c:      if (!obj->value[3])
act_obj.c:  if (obj->item_type == ITEM_WEAPON)
act_obj.c:	if (obj->value[3] < 0 || attack_table[obj->value[3]].damage == DAM_BASH)
act_obj.c:  if (obj->item_type != ITEM_DRINK_CON)
act_obj.c:  if (obj->value[1] != 0 && obj->value[2] != fountain->value[2])
act_obj.c:  if (obj->value[1] >= obj->value[0])
act_obj.c:  obj->value[2] = fountain->value[2];
act_obj.c:  obj->value[1] = obj->value[0];
act_obj.c:      for (obj = ch->in_room->contents; obj; obj = obj->next_content)
act_obj.c:	  if (obj->item_type == ITEM_FOUNTAIN && can_see_obj(ch,obj))
act_obj.c:  switch (obj->item_type)
act_obj.c:      if ((liquid = obj->value[2]) < 0)
act_obj.c:	  liquid = obj->value[2] = 0;
act_obj.c:      if (obj->value[1] <= 0)
act_obj.c:      if ((liquid = obj->value[2]) < 0)
act_obj.c:	  liquid = obj->value[2] = 0;
act_obj.c:      amount = UMIN (amount, obj->value[1]);
act_obj.c:  if (obj->value[3] != 0)
act_obj.c:  if (obj->value[0] > 0)
act_obj.c:    obj->value[1] -= amount;
act_obj.c:      if (ch->race == PC_RACE_KALIAN && obj->item_type == ITEM_FOOD)
act_obj.c:      if (obj->item_type != ITEM_FOOD && obj->item_type != ITEM_PILL 
act_obj.c:		      && !(IS_SET(ch->act2,ACT_FAMILIAR) && obj->pIndexData->vnum == OBJ_VNUM_EYE)
act_obj.c:		      && !(ch->Class == PC_CLASS_CHAOS_JESTER && obj->item_type == ITEM_FEATHER)
act_obj.c:      if (!IS_NPC (ch) && obj->item_type == ITEM_PILL && ch->pcdata->condition[COND_PILLS] >= 3)
act_obj.c:      if (!IS_NPC (ch) && obj->item_type == ITEM_FOOD && ch->pcdata->condition[COND_FULL] > 40)
act_obj.c:  switch (obj->item_type)
act_obj.c:	  gain_condition (ch, COND_FULL, obj->value[0]);
act_obj.c:	  gain_condition (ch, COND_HUNGER, obj->value[1]);
act_obj.c:	 if (IS_SET(ch->act2,ACT_FAMILIAR) && (obj->pIndexData->vnum == OBJ_VNUM_TORN_HEART 
act_obj.c:			 || obj->pIndexData->vnum == OBJ_VNUM_BRAINS))
act_obj.c:      if (obj->value[3] != 0)
act_obj.c:	  af.level = number_fuzzy (obj->value[0]);
act_obj.c:	  af.duration = 2 * obj->value[0];
act_obj.c:      obj_cast_spell (obj->value[1], obj->value[0], ch, ch, NULL);
act_obj.c:      obj_cast_spell (obj->value[2], obj->value[0], ch, ch, NULL);
act_obj.c:      obj_cast_spell (obj->value[3], obj->value[0], ch, ch, NULL);
act_obj.c:      obj_cast_spell (obj->value[4], obj->value[0], ch, ch, NULL);
act_obj.c:  if (IS_SET (obj->extra_flags[0], ITEM_NOREMOVE) && !IS_IMMORTAL (ch))
act_obj.c:  if (obj->item_type == ITEM_POLE && ch->pcdata && ch->pcdata->fishing)
act_obj.c:  if (obj->item_type == ITEM_WEAPON && IS_WEAPON_STAT(obj,WEAPON_HOLY_ACTIVATED))
act_obj.c:    REMOVE_BIT(obj->value[4],WEAPON_HOLY_ACTIVATED);
act_obj.c:  if (obj->item_type == ITEM_POLE)
act_obj.c:    obj->value[1] = 0;
act_obj.c:  if (IS_SET (obj->extra_flags[0], ITEM_NOREMOVE) && !IS_IMMORTAL (ch))
act_obj.c:  if (obj->item_type == ITEM_POLE && ch->pcdata && ch->pcdata->fishing)
act_obj.c:  if (obj->item_type == ITEM_WEAPON && IS_WEAPON_STAT(obj,WEAPON_HOLY_ACTIVATED))
act_obj.c:    REMOVE_BIT(obj->value[4],WEAPON_HOLY_ACTIVATED);
act_obj.c:  if (obj->item_type == ITEM_POLE)
act_obj.c:    obj->value[1] = 0;
act_obj.c:  if (IS_SET (obj->extra_flags[0], ITEM_NOREMOVE) && !IS_IMMORTAL (ch))
act_obj.c:  if (obj->item_type == ITEM_POLE && ch->pcdata && ch->pcdata->fishing)
act_obj.c:  if (obj->item_type == ITEM_WEAPON && IS_WEAPON_STAT(obj,WEAPON_HOLY_ACTIVATED))
act_obj.c:    REMOVE_BIT(obj->value[4],WEAPON_HOLY_ACTIVATED);
act_obj.c:  if (obj->item_type == ITEM_POLE)
act_obj.c:    obj->value[1] = 0;
act_obj.c:  if (IS_SET (obj->extra_flags[0], ITEM_NOREMOVE) && !IS_IMMORTAL (ch))
act_obj.c:  if (obj->item_type == ITEM_POLE && ch->pcdata && ch->pcdata->fishing)
act_obj.c:  if (obj->item_type == ITEM_WEAPON && IS_WEAPON_STAT(obj,WEAPON_HOLY_ACTIVATED))
act_obj.c:    REMOVE_BIT(obj->value[4],WEAPON_HOLY_ACTIVATED);
act_obj.c:  if (obj->item_type == ITEM_POLE)
act_obj.c:    obj->value[1] = 0;
act_obj.c:  if (IS_CLASS(ch, PC_CLASS_DRUID) && (obj->item_type == ITEM_WEAPON) && (obj->value[0] != WEAPON_STAFF)) {
act_obj.c:  if (obj->plr_owner != NULL)
act_obj.c:    if (str_cmp (ch->name, obj->plr_owner) && !IS_IMMORTAL(ch))
act_obj.c:	sprintf (buf, "You do not own %s!\n\r", obj->short_descr);
act_obj.c:  if (ch->level < (obj->level - EQUIP_LEVEL_DIFF))
act_obj.c:	       (obj->level - EQUIP_LEVEL_DIFF));
act_obj.c:  if (((str_cmp (obj->material, "steel") == 0) ||
act_obj.c:       (str_cmp (obj->material, "iron") == 0)) &&
act_obj.c:    if (IS_SET(obj->wear_flags,ITEM_WIELD) || IS_SET(obj->wear_flags,ITEM_WEAR_ARMS)
act_obj.c:	    || IS_SET(obj->wear_flags,ITEM_WEAR_HANDS) || IS_SET(obj->wear_flags,ITEM_WEAR_SHIELD))
act_obj.c:    if (!(IS_SET(obj->wear_flags,ITEM_HOLD) || 
act_obj.c: 	    (IS_SET(obj->wear_flags,ITEM_WEAR_BODY) && IS_SET(obj->race_flags,RACE_SWARM))
act_obj.c:		    || !IS_SET(obj->wear_flags,ITEM_WEAR_FLOAT) || obj->item_type == ITEM_LIGHT))
act_obj.c:       if (obj->item_type == ITEM_LIGHT
act_obj.c:           || (!IS_SET(obj->wear_flags,ITEM_WEAR_HEAD)
act_obj.c:		   && !IS_SET(obj->wear_flags,ITEM_WEAR_SHIELD)
act_obj.c:		   && !IS_SET(obj->wear_flags,ITEM_WIELD)))
act_obj.c:      if (obj->item_type == ITEM_LIGHT
act_obj.c:          || (!IS_SET(obj->wear_flags,ITEM_WEAR_LEGS)
act_obj.c:                && !IS_SET(obj->wear_flags,ITEM_WIELD)
act_obj.c:                && !IS_SET(obj->wear_flags,ITEM_WEAR_BODY)))
act_obj.c:      if (obj->item_type != ITEM_LIGHT
act_obj.c:          && (!IS_SET(obj->wear_flags,ITEM_WEAR_FLOAT)))
act_obj.c:  if (IS_CLASS (ch, PC_CLASS_ASSASSIN) && IS_SET(obj->wear_flags,ITEM_WEAR_SHIELD))
act_obj.c:  if (IS_SET(obj->wear_flags,ITEM_WEAR_BODY) && is_affected(ch,skill_lookup("swell")))
act_obj.c:    if (hands_needed && IS_SET(obj->wear_flags,ITEM_WEAR_SHIELD) && get_eq_char_new(ch,ITEM_WEAR_SHIELD) 
act_obj.c:    if (hands_needed && IS_SET(obj->wear_flags,ITEM_HOLD) && get_eq_char_new(ch,ITEM_HOLD) 
act_obj.c:      if (held->item_type == ITEM_INSTRUMENT && IS_SET (obj->value[0], A) && ch->size < SIZE_LARGE)
act_obj.c: 	    (IS_SET(obj->wear_flags,ITEM_HOLD) || IS_SET(obj->wear_flags,ITEM_WIELD)
act_obj.c:	     || IS_SET(obj->wear_flags,ITEM_TWO_HANDS) || IS_SET(obj->wear_flags,ITEM_WEAR_SHIELD)))
act_obj.c:	     ((obj->item_type == ITEM_INSTRUMENT && IS_SET (obj->value[0], A) && ch->size < SIZE_LARGE) ||
act_obj.c:	     (obj->item_type == ITEM_WEAPON && ch->size < SIZE_LARGE && IS_WEAPON_STAT (obj, WEAPON_TWO_HANDS))))
act_obj.c:	 && IS_SET(obj->wear_flags,ITEM_WIELD))
act_obj.c:  if (IS_SET(obj->wear_flags,ITEM_WIELD) && obj->item_type != ITEM_WEAPON)
act_obj.c:  if (!(obj->wear_flags & ~(ITEM_TAKE) & ~(ITEM_NO_SAC)) && obj->item_type != ITEM_LIGHT)
act_obj.c:  if (IS_SET(obj->extra_flags[1],ITEM_INVIS_WEAR))
act_obj.c:  send_to_char (obj->short_descr,ch);
act_obj.c:    if (IS_SET(obj->wear_flags,wear_conversion_table[i].wear_flag))
act_obj.c:		      && IS_SET(obj->wear_flags,ITEM_WEAR_FINGER))
act_obj.c:		      && IS_SET(obj->wear_flags,ITEM_WEAR_NECK))
act_obj.c:		      && IS_SET(obj->wear_flags,ITEM_WEAR_WRIST))
act_obj.c:	      	      && IS_SET(obj->wear_flags,ITEM_WIELD))
act_obj.c:		      && IS_SET(obj->wear_flags,ITEM_WEAR_ANOTHER_WRIST))
act_obj.c:		       && IS_SET(obj->wear_flags,ITEM_WEAR_ANOTHER_FINGER))
act_obj.c:		       && IS_SET(obj->wear_flags,ITEM_WEAR_ANOTHER_NECK))
act_obj.c:  if (IS_SET(obj->wear_flags,ITEM_WIELD))
act_obj.c:      if (IS_SET(obj->wear_loc,ITEM_WIELD))
act_obj.c:/*wear_flags_remaining = obj->wear_flags;
act_obj.c:  if (obj->item_type == ITEM_LIGHT || IS_SET(wear_flags_remaining,ITEM_WEAR_LIGHT))
act_obj.c:      if (IS_SET (obj->wear_flags, ITEM_WIELD) && IS_CLASS (ch, PC_CLASS_REAVER))
act_obj.c:      if (IS_SET (obj->wear_flags, ITEM_WIELD) && IS_CLASS (ch, PC_CLASS_MONK))
act_obj.c:	if (IS_CLASS(ch, PC_CLASS_DRUID) && (obj->item_type == ITEM_WEAPON) && (obj->value[0] != WEAPON_STAFF)) {
act_obj.c:      if (obj->item_type == ITEM_INSTRUMENT)
act_obj.c:	  if (IS_SET (obj->value[0], A))
act_obj.c:	  obj_next = obj->next_content;
act_obj.c:	  if (IS_SET (ch->act, ACT_PET) && obj->item_type != ITEM_CLOTHING)
act_obj.c:	  if (IS_SET (obj->wear_flags, ITEM_WIELD) && (IS_CLASS (ch, PC_CLASS_REAVER) || IS_CLASS (ch, PC_CLASS_MONK)))
act_obj.c:	  if (IS_SET (obj->wear_flags, ITEM_WORN_WINGS) && (!ch->race ==PC_RACE_NERIX))
act_obj.c:	  if (obj->wear_loc == WEAR_NONE && can_see_obj (ch, obj))
act_obj.c:      if (IS_SET (obj->wear_flags, ITEM_WIELD) && IS_CLASS (ch, PC_CLASS_REAVER))
act_obj.c:      if (IS_SET (obj->wear_flags, ITEM_WIELD) && IS_CLASS (ch, PC_CLASS_MONK))
act_obj.c:      if (obj->item_type != ITEM_CLOTHING && IS_SET (ch->act, ACT_PET))
act_obj.c:	  || !is_name (arg, obj->name))
act_obj.c:	    || !is_name (arg, obj->name))
act_obj.c:	  obj_next = obj->next_content;
act_obj.c:	  if (obj->wear_loc != WEAR_NONE && can_see_obj (ch, obj))
act_obj.c:      || IS_SET (obj->extra_flags[0], ITEM_NOSAC))
act_obj.c:  if (obj->item_type == ITEM_FURNITURE || obj->item_type == ITEM_RAFT)
act_obj.c:	      if (obj->item_type == ITEM_FURNITURE)
act_obj.c:  silver = UMAX (1, obj->level * 2);
act_obj.c:  if (obj->item_type != ITEM_CORPSE_NPC && obj->item_type != ITEM_CORPSE_PC)
act_obj.c:    silver = UMIN (silver, obj->cost);
act_obj.c:  if (obj->item_type == ITEM_SCROLL)
act_obj.c:  obj_cast_spell (sn, obj->level, ch, ch, obj);
act_obj.c:  if (obj->item_type != ITEM_POTION && obj->item_type != ITEM_VIAL)
act_obj.c:  if (obj->item_type == ITEM_VIAL && obj->value[0] == 0)
act_obj.c:      sprintf (tcbuf, "Sorry, %s is currently empty.\n\r", obj->short_descr);
act_obj.c:  if (ch->level < (obj->level - MAGIC_LEVEL_DIFF))
act_obj.c:  if (obj->item_type == ITEM_POTION)
act_obj.c:      obj_cast_spell (obj->value[1], obj->value[0], ch, ch, NULL);
act_obj.c:      obj_cast_spell (obj->value[2], obj->value[0], ch, ch, NULL);
act_obj.c:      obj_cast_spell (obj->value[3], obj->value[0], ch, ch, NULL);
act_obj.c:      obj_cast_spell (obj->value[4], obj->value[0], ch, ch, NULL);
act_obj.c:      if (obj->value[0] != -1)
act_obj.c:	obj_cast_spell (obj->value[0], obj->level, ch, ch, NULL);
act_obj.c:	spell_poison (gsn_poison, obj->level, ch, ch, TARGET_CHAR);
act_obj.c:      obj->value[0] = 0;
act_obj.c:  if (!IS_SET (obj->extra_flags[0], ITEM_PERMSTOCK))
act_obj.c:      || IS_SET (obj->extra_flags[0], ITEM_INVENTORY) || obj->level > ch->level)
act_obj.c:   if (IS_SET(obj->extra_flags[0],ITEM_NOMOB) && IS_NPC(ch))
act_obj.c:  if (obj->plr_owner != NULL)
act_obj.c:	  if (str_cmp (ch->name, obj->plr_owner) && !IS_IMMORTAL(ch))
act_obj.c:		  sprintf (buf, "You do not own %s!\n\r", obj->short_descr);
act_obj.c:  location = get_room_index (obj->value[0]);
act_obj.c:  for (vobj = location->contents; vobj != NULL; vobj = vobj->next_content)
act_obj.c:    new_weight += vobj->weight;
act_obj.c:  obj->weight = new_weight;
act_obj.c:      t_obj_next = t_obj->next_content;
act_obj.c:      if (obj->pIndexData == t_obj->pIndexData
act_obj.c:	  && !str_cmp (obj->short_descr, t_obj->short_descr))
act_obj.c:	  obj->cost = t_obj->cost;	/* keep it standard */
act_obj.c:      obj->next_content = ch->carrying;
act_obj.c:      obj->next_content = t_obj->next_content;
act_obj.c:      t_obj->next_content = obj;
act_obj.c:  obj->carried_by = ch;
act_obj.c:  obj->in_room = NULL;
act_obj.c:  obj->in_obj = NULL;
act_obj.c:  for (obj = keeper->carrying; obj != NULL; obj = obj->next_content)
act_obj.c:      if (obj->wear_loc == WEAR_NONE && can_see_obj (keeper, obj)
act_obj.c:	  && can_see_obj (ch, obj) && is_name (arg, obj->name))
act_obj.c:	  while (obj->next_content != NULL
act_obj.c:		 && obj->pIndexData == obj->next_content->pIndexData
act_obj.c:		 && !str_cmp (obj->short_descr,
act_obj.c:			      obj->next_content->short_descr))
act_obj.c:	    obj = obj->next_content;
act_obj.c:      cost = obj->cost * pShop->profit_buy / 100;
act_obj.c:	  if (obj->item_type == pShop->buy_type[itype])
act_obj.c:	      cost = obj->cost * pShop->profit_sell / 100;
act_obj.c:	    if (obj->pIndexData == obj2->pIndexData
act_obj.c:		&& !str_cmp (obj->short_descr, obj2->short_descr))
act_obj.c:  if (obj->item_type == ITEM_STAFF || obj->item_type == ITEM_WAND)
act_obj.c:      if (obj->value[1] == 0)
act_obj.c:	cost = cost * obj->value[2] / obj->value[1];
act_obj.c:	  for (obj = pRoom->contents; obj; obj = obj->next_content)
act_obj.c:	    if (obj->item_type == ITEM_CTRANSPORT)
act_obj.c:      cost = obj->cost;
act_obj.c:      if (obj->level - 10 > ch->level)
act_obj.c:	  if (obj2->pIndexData == obj->pIndexData)
act_obj.c:      if (obj->item_type != ITEM_CTRANSPORT)
act_obj.c:  	        sprintf(buf,"%s buys %d %s from %s for %d at %d.",ch->name, number, obj->short_descr,keeper->name,cost*number,ch->in_room->vnum);
act_obj.c:	      else sprintf(buf,"%s buys %s from %s for %d at %d.",ch->name,obj->short_descr,keeper->name,cost*number,ch->in_room->vnum);
act_obj.c:  	        sprintf(buf,"%s buys %d %s from %s's store for %d at %d.",ch->name,number,obj->short_descr,ch->in_room->owner,total,ch->in_room->vnum);
act_obj.c:	      else sprintf(buf,"%s buys %s from %s's store for %d at %d.",ch->name,obj->short_descr,ch->in_room->owner,total,ch->in_room->vnum);
act_obj.c:		      sprintf(buf,"oocnote + Buyer - %s, Item - %s, Money Made (after commission) - %d",ch->name,obj->short_descr,total);
act_obj.c:	  if (!IS_SET (obj->extra_flags[0], ITEM_PERMSTOCK))
act_obj.c:	      if (IS_SET (t_obj->extra_flags[0], ITEM_DONATE))
act_obj.c:		t_obj->cost = 0;
act_obj.c:		t_obj->cost = t_obj->pIndexData->cost;
act_obj.c:	    t_obj = create_object (obj->pIndexData, obj->level);
act_obj.c:	  if (t_obj->timer > 0 && !IS_OBJ_STAT (t_obj, ITEM_HAD_TIMER))
act_obj.c:	    t_obj->timer = 0;
act_obj.c:	  REMOVE_BIT (t_obj->extra_flags[0], ITEM_HAD_TIMER);
act_obj.c:	  if (cost < t_obj->cost)
act_obj.c:	    t_obj->cost = cost;
act_obj.c:	  for (t_obj = obj->next_content;
act_obj.c:	       count < number && t_obj != NULL; t_obj = t_obj->next_content)
act_obj.c:	      if (t_obj->pIndexData ==
act_obj.c:		  obj->pIndexData && !str_cmp (t_obj->short_descr,
act_obj.c:					       obj->short_descr))
act_obj.c:      if (obj->level - 20 > ch->level)
act_obj.c:      if (obj->item_type != ITEM_CTRANSPORT)
act_obj.c:	  cost -= obj->cost / 2 * roll / 100;
act_obj.c:	  cost -= obj->cost / 2 * roll / 100;
act_obj.c:		   keeper->short_descr, obj->short_descr, cost);
act_obj.c:      if (obj->item_type != ITEM_CTRANSPORT)
act_obj.c:	      if (IS_SET (obj->extra_flags[0], ITEM_INVENTORY))
act_obj.c:		t_obj = create_object (obj->pIndexData, obj->level);
act_obj.c:		  obj = obj->next_content;
act_obj.c:	      if (t_obj->timer > 0 && !IS_OBJ_STAT (t_obj, ITEM_HAD_TIMER))
act_obj.c:		t_obj->timer = 0;
act_obj.c:	      REMOVE_BIT (t_obj->extra_flags[0], ITEM_HAD_TIMER);
act_obj.c:	      if (cost < t_obj->cost)
act_obj.c:		t_obj->cost = cost;
act_obj.c:	  if (obj->value[6] > 0)
act_obj.c:	      obj->owner = str_dup (vbuf);
act_obj.c:	      key_obj_i = get_obj_index (obj->value[6]);
act_obj.c:		  key_obj = create_object (get_obj_index (obj->value[6]), 0);
act_obj.c:		      key_obj->owner = str_dup (vbuf);
act_obj.c:      for (obj = keeper->carrying; obj; obj = obj->next_content)
act_obj.c:	  if (obj->wear_loc == WEAR_NONE && can_see_obj (ch, obj)
act_obj.c:	      && (arg[0] == '\0' || is_name (arg, obj->name)))
act_obj.c:		sprintf (buf, "[%2d %5d -- ] %s\n\r", obj->level,
act_obj.c:			 cost, obj->short_descr);
act_obj.c:		  while (obj->next_content != NULL
act_obj.c:			 && obj->pIndexData ==
act_obj.c:			 obj->next_content->
act_obj.c:			 pIndexData && !str_cmp (obj->short_descr,
act_obj.c:						 obj->next_content->
act_obj.c:		      obj = obj->next_content;
act_obj.c:		  sprintf (buf, "[%2d %5d %2d ] %s\n\r", obj->level,
act_obj.c:			   cost, count, obj->short_descr);
act_obj.c:	  for (obj = pRoom->contents; obj; obj = obj->next_content)
act_obj.c:	    if (obj->item_type == ITEM_CTRANSPORT
act_obj.c:		&& is_name (name, obj->name))
act_obj.c:		    obj->value[6] && !str_cmp (kObj->owner, obj->owner))
act_obj.c:      cost += obj->cost / 2 * roll / 100;
act_obj.c:  if (obj->item_type == ITEM_CTRANSPORT)
act_obj.c:	  if (kObj->pIndexData->vnum == obj->value[6]
act_obj.c:	      && !str_cmp (kObj->owner, obj->owner))
act_obj.c:  else if (obj->item_type == ITEM_TRASH
act_obj.c:      if (obj->timer)
act_obj.c:	SET_BIT (obj->extra_flags[0], ITEM_HAD_TIMER);
act_obj.c:	obj->timer = number_range (50, 100);
act_obj.c:      switch (obj->rarity)
act_obj.c:      base -= (obj->count * 2);
act_obj.c:      switch (obj->rarity)
act_obj.c:      if (obj->rarity == RARITY_ALWAYS)
act_obj.c:      if (obj->rarity == RARITY_VERY_RARE)
act_obj.c:	   rarity_Class, obj->count, base);
act_obj.c:  if (obj->wear_loc != WEAR_NONE)
act_obj.c:  if (number_percent () >= get_skill (ch, gsn_falconry) || obj->weight > 20)
act_obj.c:  for (counter = obj->contains; counter != NULL;
act_wiz.c:		obj_next = obj->next;
act_wiz.c:		if (obj->in_room == NULL)
act_wiz.c:		if (obj->in_room->area == ch->in_room->area)
act_wiz.c:		paf->next = obj->affected;
act_wiz.c:		obj->affected = paf;
act_wiz.c:		obj_next = obj->next_content;
act_wiz.c:		if (vnum != 0 && obj->pIndexData->vnum == vnum)
act_wiz.c:		if (obj->pIndexData->vnum == OBJ_VNUM_MAP)
act_wiz.c:		if (obj->pIndexData->vnum == OBJ_VNUM_SCHOOL_BANNER)
act_wiz.c:		if (obj->pIndexData->vnum == OBJ_VNUM_SCHOOL_VEST)
act_wiz.c:		if (obj->pIndexData->vnum == OBJ_VNUM_SCHOOL_SHIELD)
act_wiz.c:		if (obj->pIndexData->vnum == OBJ_VNUM_SCHOOL_BOOTS)
act_wiz.c:		if (obj->pIndexData->vnum == OBJ_VNUM_SCHOOL_LEGS)
act_wiz.c:		obj->cost = 0;
act_wiz.c:		obj->cost = 0;
act_wiz.c:		obj->cost = 0;
act_wiz.c:		obj->cost = 0;
act_wiz.c:		obj->cost = 0;
act_wiz.c:		return obj->in_room;
act_wiz.c:	for (obj = location->contents; obj; obj = obj->next_content)
act_wiz.c:		one_argument (obj->name, buf);
act_wiz.c:	if (obj->item_type == ITEM_PORTAL)
act_wiz.c:	sprintf (buf, "`jName(s):`` %s\n\r", obj->name);
act_wiz.c:		obj->pIndexData->vnum, "new", item_type_name (obj),
act_wiz.c:		obj->pIndexData->reset_num);
act_wiz.c:		obj->short_descr, obj->description);
act_wiz.c:		wear_bit_name (obj->wear_flags),
act_wiz.c:		extra_bit_name (obj->extra_flags));
act_wiz.c:		crflag_string (Class_flags, obj->Class_flags));
act_wiz.c:		crflag_string (pcrace_flags, obj->race_flags));
act_wiz.c:		crflag_string (clan_flags, obj->clan_flags));
act_wiz.c:		if (obj->objtrig[i])
act_wiz.c:			sprintf(buf, "`jObj Trigger %d Vnum:``  [%d]\n\r", i, obj->objtrig[i]->pIndexData->vnum);
act_wiz.c:		1, get_obj_number (obj), obj->weight, get_obj_weight (obj),
act_wiz.c:		obj->level, obj->cost, obj->condition, obj->timer, (obj->plr_owner == NULL)?"none":capitalize(obj->plr_owner));
act_wiz.c:		obj->in_room == NULL ? 0 : obj->in_room->vnum,
act_wiz.c:		obj->in_obj == NULL ? "(none)" : obj->in_obj->short_descr,
act_wiz.c:		obj->carried_by == NULL ? "(none)" : can_see (ch,
act_wiz.c:		obj->
act_wiz.c:		obj->carried_by->name : "someone", obj->wear_loc);
act_wiz.c:	if (obj->item_type == ITEM_CARD)
act_wiz.c:			obj->value[0], obj->value[1], obj->value[2],
act_wiz.c:			obj->value[3], obj->value[4], obj->value[5], obj->value[6], obj->value[7], obj->value[8],
act_wiz.c:			obj->value[9], obj->value[10], obj->value[11], obj->value[12]);
act_wiz.c:	else sprintf (buf, "`jValues:`` %d %d %d %d %d %d %d\n\r", obj->value[0],
act_wiz.c:		obj->value[1], obj->value[2], obj->value[3], obj->value[4], obj->value[5], obj->value[6]);
act_wiz.c:	switch (obj->item_type)
act_wiz.c:		sprintf (buf, "`jLevel`` %d `jspells of:``", obj->value[0]);
act_wiz.c:		if (obj->value[1] >= 0 && obj->value[1] < MAX_SKILL)
act_wiz.c:			send_to_char (skill_table[obj->value[1]].name, ch);
act_wiz.c:		if (obj->value[2] >= 0 && obj->value[2] < MAX_SKILL)
act_wiz.c:			send_to_char (skill_table[obj->value[2]].name, ch);
act_wiz.c:		if (obj->value[3] >= 0 && obj->value[3] < MAX_SKILL)
act_wiz.c:			send_to_char (skill_table[obj->value[3]].name, ch);
act_wiz.c:		if (obj->value[4] >= 0 && obj->value[4] < MAX_SKILL)
act_wiz.c:			send_to_char (skill_table[obj->value[4]].name, ch);
act_wiz.c:			obj->value[1], obj->value[2], obj->value[0]);
act_wiz.c:		if (obj->value[3] >= 0 && obj->value[3] < MAX_SKILL)
act_wiz.c:			send_to_char (skill_table[obj->value[3]].name, ch);
act_wiz.c:		if (obj->value[2] < 0)
act_wiz.c:				liq_table[obj->value[2]].liq_color,
act_wiz.c:				liq_table[obj->value[2]].liq_name);
act_wiz.c:		switch (obj->value[0])
act_wiz.c:			obj->value[1], obj->value[2],
act_wiz.c:			(1 + obj->value[2]) * obj->value[1] / 2);
act_wiz.c:			attack_table[obj->value[3]].noun);
act_wiz.c:		if (obj->value[4])
act_wiz.c:				weapon_bit_name (obj->value[4]));
act_wiz.c:			obj->value[0], obj->value[1], obj->value[2], obj->value[3]);
act_wiz.c:		sprintf (buf, "`jCapacity:`` %d\n\r", obj->value[0]);
act_wiz.c:		sprintf (buf, "`jBaited:`` %d\n\r", obj->value[1]);
act_wiz.c:			obj->value[0], obj->value[3], cont_bit_name (obj->value[1]));
act_wiz.c:		if (obj->value[4] != 100)
act_wiz.c:			sprintf (buf, "`jWeight multiplier:`` %d%%\n\r", obj->value[4]);
act_wiz.c:	if (obj->extra_descr != NULL || obj->pIndexData->extra_descr != NULL)
act_wiz.c:		for (ed = obj->extra_descr; ed != NULL; ed = ed->next)
act_wiz.c:		if (obj->item_type != ITEM_WRITING_PAPER)
act_wiz.c:			for (ed = obj->pIndexData->extra_descr; ed != NULL; ed = ed->next)
act_wiz.c:	for (paf = obj->affected; paf != NULL; paf = paf->next)
act_wiz.c:	if (!obj->enchanted)
act_wiz.c:		for (paf = obj->pIndexData->affected; paf != NULL; paf = paf->next)
act_wiz.c:	for (obj = object_list; obj != NULL; obj = obj->next)
act_wiz.c:		if (!can_see_obj (ch, obj) || !is_name (argument, obj->name)
act_wiz.c:			|| (ch->level < obj->level))
act_wiz.c:		while (in_obj->in_obj != NULL)
act_wiz.c:			in_obj = in_obj->in_obj;
act_wiz.c:		if ((in_obj->carried_by != NULL))
act_wiz.c:			if (can_see (ch, in_obj->carried_by))
act_wiz.c:				if (in_obj->carried_by->in_room != NULL)
act_wiz.c:						number, obj->short_descr,
act_wiz.c:						PERS (in_obj->carried_by, ch),
act_wiz.c:						in_obj->carried_by->in_room->vnum);
act_wiz.c:						number, obj->short_descr,
act_wiz.c:						PERS (in_obj->carried_by, ch));
act_wiz.c:				if (in_obj->carried_by->in_room != NULL)
act_wiz.c:						number, obj->short_descr,
act_wiz.c:						in_obj->carried_by->in_room->vnum);
act_wiz.c:						number, obj->short_descr);
act_wiz.c:			if (in_obj->in_room != NULL)
act_wiz.c:				if (can_see_room (ch, in_obj->in_room))
act_wiz.c:						number, obj->short_descr,
act_wiz.c:						in_obj->in_room->name, in_obj->in_room->vnum);
act_wiz.c:						number, obj->short_descr);
act_wiz.c:				sprintf (buf, "%3d) %s is FUBAR\n\r", number, obj->short_descr);
act_wiz.c:		next_obj = obj->next;
act_wiz.c:		if (find_all || is_name (obj_name, obj->name))
act_wiz.c:			while (in_obj->in_obj != NULL)
act_wiz.c:				in_obj = in_obj->in_obj;
act_wiz.c:			if ((in_obj->carried_by == NULL))
act_wiz.c:				if (in_obj->in_room == NULL)
act_wiz.c:								obj->short_descr);
act_wiz.c:								obj->short_descr);
act_wiz.c:			next_obj = next_obj->next;
act_wiz.c:		|| (IS_TRUSTED (ch, GOD) && obj->level <= 20
act_wiz.c:		&& obj->cost <= 1000) || (IS_TRUSTED (ch, DEMIGOD)
act_wiz.c:		&& obj->level <= 10
act_wiz.c:		&& obj->cost <= 500)
act_wiz.c:		|| (IS_TRUSTED (ch, DEMIGOD) && obj->level <= 5
act_wiz.c:		&& obj->cost <= 250) || (IS_TRUSTED (ch, DEMIGOD)
act_wiz.c:		&& obj->level == 0 && obj->cost <= 100))
act_wiz.c:	for (c_obj = obj->contains; c_obj != NULL; c_obj = c_obj->next_content)
act_wiz.c:			t_obj = create_object (c_obj->pIndexData, 0);
act_wiz.c:		if (obj->pIndexData->item_type == ITEM_CTRANSPORT
act_wiz.c:			|| obj->pIndexData->item_type == ITEM_ELEVATOR)
act_wiz.c:		clone = create_object (obj->pIndexData, 0);
act_wiz.c:		if (obj->carried_by == NULL || (IS_NPC(ch) && ch->pIndexData->vnum != MOB_VNUM_FAKIE))
act_wiz.c:		for (obj = mob->carrying; obj != NULL; obj = obj->next_content)
act_wiz.c:				new_obj = create_object (obj->pIndexData, 0);
act_wiz.c:				new_obj->wear_loc = obj->wear_loc;
act_wiz.c:	if (obj->wear_loc != -1)
act_wiz.c:		for (obj = object_list; obj != NULL; obj = obj->next)
act_wiz.c:			if (obj->pIndexData == pObjIndex)
act_wiz.c:			sprintf (buf, "You have created %s\n\r", obj->short_descr);
act_wiz.c:	for (obj = ch->carrying; obj != NULL; obj = obj->next_content)
act_wiz.c:			if (is_name (arg, obj->name))
act_wiz.c:			obj_next = obj->next_content;
act_wiz.c:		if (obj->item_type == ITEM_BINDER || obj->pIndexData->vnum == OBJ_VNUM_ANTE_BAG)
act_wiz.c:			free_string (obj->name);
act_wiz.c:			obj->name = str_dup (arg3);
act_wiz.c:			if (!IS_IMMORTAL(ch) && obj->plr_owner == NULL)
act_wiz.c:				obj->plr_owner = str_dup(ch->name);
act_wiz.c:			free_string (obj->short_descr);
act_wiz.c:			obj->short_descr = str_dup (arg3);
act_wiz.c:			if (!IS_IMMORTAL(ch) && obj->plr_owner == NULL)
act_wiz.c:				obj->plr_owner = str_dup(ch->name);
act_wiz.c:			free_string (obj->description);
act_wiz.c:			obj->description = str_dup (arg3);
act_wiz.c:			if (!IS_IMMORTAL(ch) && obj->plr_owner == NULL)
act_wiz.c:				obj->plr_owner = str_dup(ch->name);
act_wiz.c:			ed->next = obj->extra_descr;
act_wiz.c:			obj->extra_descr = ed;
act_wiz.c:			if (!IS_IMMORTAL(ch) && obj->plr_owner == NULL)
act_wiz.c:				obj->plr_owner = str_dup(ch->name);
act_wiz.c:		if (!IS_SET (obj->extra_flags[0], ITEM_PERMSTOCK))
act_wiz.c:			SET_BIT (obj->extra_flags[0], ITEM_PERMSTOCK);
act_wiz.c:			obj->cost = cost;
act_wiz.c:	sprintf (buf, "\r\n`jName(s):`` %s\n\r", obj->name);
act_wiz.c:		obj->value[1], obj->value[2],
act_wiz.c:		(1 + obj->value[2]) * obj->value[1] / 2);
act_wiz.c:		obj->short_descr, obj->description);
act_wiz.c:		attack_table[obj->value[3]].noun);
act_wiz.c:	if (obj->value[4])
act_wiz.c:			weapon_bit_name (obj->value[4]));
act_wiz.c:	if (obj->value[0] == WEAPON_DICE)
act_wiz.c:		sprintf (buf, "`jWeapon spell:`` %s\n\r",skill_table[obj->value[5]].name);
act_wiz.c:	pAf->next = obj->affected;
act_wiz.c:	obj->affected = pAf;
act_wiz.c:			&& obj->item_type == ITEM_LIGHT
act_wiz.c:			&& obj->value[2] != 0 && victim->in_room != NULL))
act_wiz.c:		obj_next = obj->next_content;
act_wiz.c:			if (obj->wear_loc != WEAR_NONE)
archery.c:      for (obj = ch->carrying; obj != NULL; obj = obj->next_content)
archery.c:	if (obj->item_type == ITEM_WEAPON
archery.c:	    && obj->value[0] == WEAPON_ARROW && can_see_obj (ch, obj))
archery.c:      for (obj = ch->carrying; obj != NULL; obj = obj->next_content)
archery.c:	if (is_name (argument, obj->name) && can_see_obj (ch, obj))
archery.c:  if (obj->item_type != ITEM_WEAPON || obj->value[0] != WEAPON_ARROW)
archery.c:      short dam = dice (obj->value[1], obj->value[2]);
archery.c:      /*if (dam < obj->value[1] * obj->value[2])
archery.c:	dam = ((dam + (obj->value[1] * obj->value[2])) / 2.0) + 1;*/
archery.c:      damage (ch, victim, dam, gsn_archery, obj->value[3], FALSE);
archery.c:	  if ((poison = affect_find (obj->affected, gsn_poison)) == NULL)
archery.c:	    level = obj->level;
archery.c:	  fire_effect ((void *) victim, obj->level / 2, dam, TARGET_CHAR);
archery.c:	  cold_effect (victim, obj->level / 2, dam, TARGET_CHAR);
archery.c:	  shock_effect (victim, obj->level / 2, dam, TARGET_CHAR);
archery.c:      obj->condition = 50;
archery.c:  obj->condition -= amount;
archery.c:  if (obj->condition <= 0)
arena.c:       some_obj = some_obj->next_content)
arena.c:       some_obj = some_obj->next_content)
arena.c:  if (some_obj->wear_loc != WEAR_NONE)
arena.c:	   some_obj->short_descr);
arena.c:	   some_obj->short_descr);
arena.c:	      obj_next = obj->next_content;
arena.c:	      obj->prev_wear_loc = obj->wear_loc;
arena.c:	      obj->next_content = current_duel->old_carry_1;
arena.c:	      obj_next = obj->next_content;
arena.c:	      obj->prev_wear_loc = obj->wear_loc;
arena.c:	      obj->next_content = current_duel->old_carry_2;
arena.c:      arena_obj->level = level_avg;
arena.c:      arena_obj->level = level_avg;
arena.c:  arena_obj->level = level_avg;
arena.c:  arena_obj->level = level_avg;
arena.c:  arena_obj->level = level_avg;
arena.c:  arena_obj->level = level_avg;
arena.c:  arena_obj->level = level_avg;
arena.c:      arena_obj->level = level_avg;
arena.c:  arena_obj->level = level_avg;
arena.c:      obj_next = obj->next_content;
arena.c:      obj_next = obj->next_content;
arena.c:      obj_next = obj->next_content;
arena.c:      equip_char_slot_new (current_duel->in_duel_1, obj, obj->prev_wear_loc);
arena.c:      obj_next = obj->next_content;
arena.c:      equip_char_slot_new (current_duel->in_duel_2, obj, obj->prev_wear_loc);
arena.c:      obj_next = obj->next_content;
arena.c:      obj_next = obj->next_content;
arena.c:      obj_next = obj->next_content;
arena.c:      equip_char_slot_new (current_duel->in_duel_1, obj, obj->prev_wear_loc);
arena.c:      obj_next = obj->next_content;
arena.c:      equip_char_slot_new (current_duel->in_duel_2, obj, obj->prev_wear_loc);
bit.c:		if (GLOBAL_ot_obj && is_name (arg1, GLOBAL_ot_obj->name))
bit.c:		obj->value[0] = value;
bit.c:		obj->value[1] = value;
bit.c:		obj->value[2] = value;
bit.c:		obj->value[3] = value;
bit.c:		obj->value[4] = value;
bit.c:		if (obj->item_type == ITEM_WEAPON && obj->value[0] == WEAPON_DICE)
bit.c:			if (obj->value[4] & WEAPON_SHARP)
bit.c:				obj->value[4] -= WEAPON_SHARP;
bit.c:		obj->value[5] = value;
bit.c:		if (obj->item_type == ITEM_WEAPON && obj->value[0] == WEAPON_DICE)
bit.c:				obj->value[5] = 0;
bit.c:		obj->value[6] = value;
bit.c:		obj->value[7] = value;
bit.c:		obj->value[8] = value;
bit.c:		obj->value[9] = value;
bit.c:		obj->value[10] = value;
bit.c:		obj->value[11] = value;
bit.c:		obj->value[12] = value;
bit.c:					TOGGLE_BIT (obj->extra_flags[i], value);
bit.c:			obj->extra_flags[0] = value;
bit.c:		obj->wear_flags = value;
bit.c:		obj->level = value;
bit.c:		obj->weight = value;
bit.c:		obj->cost = value;
bit.c:		obj->timer = value;
bit.c:				if (obj->plr_owner)
bit.c:					free_string (obj->plr_owner);
bit.c:				obj->plr_owner = NULL;
bit.c:				if (obj->plr_owner)
bit.c:					free_string (obj->plr_owner);
bit.c:				obj->plr_owner = str_dup (arg3);
bit.c:			//            sprintf(buf,"name of item is -> %s\n\r",obj->name);
bit.c:			if (obj->objtrig[i])
bit.c:				if (obj->objtrig[i]->pIndexData->vnum == value)
bit.c:					free_ot(obj->objtrig[i]);
bit.c:					obj->objtrig[k] = obj->objtrig[k+1];
bit.c:					if (obj->objtrig[k])
bit.c:					sprintf(buf,"moving %d to i -> %d \n\r",obj->objtrig[k]->pIndexData->vnum,i);
bit.c:					obj->objtrig[MAX_OBJ_TRIGS-1] = NULL;*/
bit.c:				obj->objtrig[i] = new_ot(value);
bit.c:				obj->objtrig[i]->obj_on = obj;
bounty.c:      for (obj = ch->carrying; obj != NULL; obj = obj->next)
bounty.c:	  if (is_name (arg2, obj->name)
bounty.c:	      && (obj->pIndexData->vnum == OBJ_VNUM_SEVERED_HEAD))
cardgame.c:	obj_next = obj->next_content;
cardgame.c:	obj->bs_capacity[0] = 0;
cardgame.c:      obj_next = obj->next_content;
cardgame.c:      if (obj->item_type != ITEM_CARD)
cardgame.c: 	  if (obj->value[1] != type)
cardgame.c:        else if (obj->value[1] < type)
cardgame.c:      if (obj->pIndexData->vnum != OBJ_VNUM_COMMON_CARD && binder->pIndexData->vnum == OBJ_VNUM_DECK)
cardgame.c:	  for (tobj = binder->contains;tobj != NULL;tobj = tobj->next_content)
cardgame.c:	      if (tobj->pIndexData->vnum == obj->pIndexData->vnum)
cardgame.c:      for (obj = binder->contains;obj != NULL;obj = obj->next_content)
cardgame.c:	 if (obj->pIndexData->vnum == card->pIndexData->vnum && binder->pIndexData->vnum == OBJ_VNUM_DECK)
cardgame.c:    for (obj = binder->contains;obj != NULL;obj = obj->next_content)
cardgame.c:      switch (obj->value[1])
cardgame.c:            obj->bs_capacity[0],obj->value[0],obj->short_descr,"Mob",obj->value[7],obj->value[8],obj->value[9]);
cardgame.c:	    obj->bs_capacity[0],obj->value[0],obj->short_descr,"Terrain");
cardgame.c:	    sprintf(arg1,"%s - %d / %d / %d / %d",flag_string (card_terrain_type, obj->value[7]), 
cardgame.c:		obj->value[8],obj->value[9],obj->value[10],obj->value[11]);
cardgame.c:	    sprintf(arg1," - %s\n\r``",flag_string (card_terrain_toggles, obj->value[12]));
cardgame.c:	  sprintf(arg1,"`d%d) - #%d %s`d - Heal spell - Amount: %d\n\r``",obj->bs_capacity[0],obj->value[0],obj->short_descr, obj->value[7]);
cardgame.c:	  sprintf(arg1,"`d%d) - #%d %s`d - Damage spell - Amount: %d\n\r``",obj->bs_capacity[0],obj->value[0],obj->short_descr, obj->value[7]);
cardgame.c:	  sprintf(arg1,"`d%d) - #%d %s`d - Boost spell - Off: %d/ Def: %d\n\r``",obj->bs_capacity[0],obj->value[0],obj->short_descr, obj->value[7], obj->value[8]);
cardgame.c:	  sprintf(arg1,"`d%d) - #%d %s`d - Counter spell\n\r``",obj->bs_capacity[0],obj->value[0],obj->short_descr);
cardgame.c:	default: sprintf(arg1,"`d%d) - #%d %s - %s\n\r``",obj->bs_capacity[0],obj->value[0],obj->short_descr,flag_string (card_Class, obj->value[1]));
cardgame.c:	for (obj = binder->contains;obj != NULL;obj = obj->next_content)
cardgame.c:	    if (obj->bs_capacity[0] == pos)
cardgame.c:  for (obj = ch->carrying;obj != NULL;obj = obj->next_content)
cardgame.c:    if (obj->pIndexData->vnum == vnum)
cardgame.c:      if (!str_cmp(obj->name,arg))
cardgame.c:  for (obj = hand->contains;obj != NULL;obj = obj->next_content,++i)
cardgame.c:      switch (obj->value[1])
cardgame.c:		  i,obj->value[0],obj->short_descr,"Mob",obj->value[7],obj->value[8],obj->value[9]);
cardgame.c:		  i,obj->value[0],obj->short_descr,"Terrain");
cardgame.c:	  sprintf(arg1,"%s - %d / %d / %d / %d",flag_string (card_terrain_type, obj->value[7]),
cardgame.c:		  obj->value[8],obj->value[9],obj->value[10],obj->value[11]);
cardgame.c:	  sprintf(arg1," - %s\n\r``",flag_string (card_terrain_toggles, obj->value[12]));
cardgame.c:	  sprintf(arg1,"`d%d) - #%d %s`d - Heal spell - Amount: %d\n\r``",i,obj->value[0],obj->short_descr, obj->value[7]);
cardgame.c:	  sprintf(arg1,"`d%d) - #%d %s`d - Damage spell - Amount: %d\n\r``",i,obj->value[0],obj->short_descr, obj->value[7]);
cardgame.c:	  sprintf(arg1,"`d%d) - #%d %s`d - Boost spell - Off: %d/ Def: %d\n\r``",i,obj->value[0],obj->short_descr, obj->value[7], obj->value[8]);
cardgame.c:	  sprintf(arg1,"`d%d) - #%d %s`d - Counter spell\n\r``",i,obj->value[0],obj->short_descr);
cardgame.c:	default: sprintf(arg1,"`d%d) - #%d %s - %s\n\r``",i,obj->value[0],obj->short_descr,flag_string (card_Class, obj->value[1]));
cardgame.c:  for (obj = obj_from->contains;obj != NULL;obj = obj->next_content)
cardgame.c:  for (obj = container->contains;obj != NULL; obj = obj->next_content,++counter);
cardgame.c:  	  obj_next = obj->next_content;
cardgame.c:  	      obj_next = obj->next_content;
cardgame.c:	  obj_next = obj->next_content;
cardgame.c:	  if (obj->wear_loc != WEAR_NONE)
cardgame.c:	  if (obj->item_type == ITEM_QUIVER || obj->item_type == ITEM_CONTAINER
cardgame.c:	      || obj->item_type == ITEM_PACK || obj->item_type == ITEM_BINDER)
cardgame.c:	  obj_next = obj->next_content;
cardgame.c:	      obj_next = obj->next_content;
cardgame.c:      if (obj->value[5] > 0)
cardgame.c:	sprintf(buf,"     %d silver\n\r",obj->value[5]);
cardgame.c:      if (obj->value[6] > 0)
cardgame.c:        sprintf(buf,"     %d gold\n\r",obj->value[6]);
cardgame.c:      show_list_to_char (obj->contains, ch, TRUE, TRUE);
cardgame.c:	  if (obj->value[5] > 0)
cardgame.c:	      sprintf(buf,"     %d silver\n\r",obj->value[5]);
cardgame.c:	  if (obj->value[6] > 0)
cardgame.c:              sprintf(buf,"     %d gold\n\r",obj->value[6]);
cardgame.c:	  show_list_to_char (obj->contains, ch, TRUE, TRUE);
cardgame.c:  switch (obj->value[1])
cardgame.c:	      obj->value[0],obj->short_descr,"Mob",obj->value[7],obj->value[8],obj->value[9]);
cardgame.c:	      obj->value[0],obj->short_descr,"Terrain");
cardgame.c:      sprintf(arg1,"%s - %d / %d / %d / %d",flag_string (card_terrain_type, obj->value[7]),
cardgame.c:	      obj->value[8],obj->value[9],obj->value[10],obj->value[11]);
cardgame.c:      sprintf(arg1," - %s\n\r``",flag_string (card_terrain_toggles, obj->value[12]));
cardgame.c:      sprintf(arg1,"`d#%d %s`d - Heal spell - Amount: %d\n\r``",obj->value[0],obj->short_descr, obj->value[7]);
cardgame.c:      sprintf(arg1,"`d#%d %s`d - Damage spell - Amount: %d\n\r``",obj->value[0],obj->short_descr, obj->value[7]);
cardgame.c:      sprintf(arg1,"`d#%d %s`d - Boost spell - Off: %d/ Def: %d\n\r``",obj->value[0],obj->short_descr, obj->value[7], obj->value[8]);
cardgame.c:      sprintf(arg1,"`d#%d %s`d - Counter spell\n\r``",obj->value[0],obj->short_descr);
cardgame.c:    default: sprintf(arg1,"`d#%d %s - %s\n\r``",obj->value[0],obj->short_descr,flag_string (card_Class, obj->value[1]));
cardgame.c:  switch (obj->value[1])
cardgame.c:              obj->value[0],obj->short_descr,"Mob",mob_owner->pcdata->cg_mm_value[CARDGAME_MOB_HP],
cardgame.c:              obj->value[0],obj->short_descr,"Mob",mob_owner->pcdata->cg_sm_value[CARDGAME_MOB_HP],
cardgame.c:  if (obj->type != ITEM_CARD)
cardgame.c:    if (obj->item_type != ITEM_CARD)
cardgame.c:  if (obj->item_type == ITEM_CONTAINER || obj->item_type == ITEM_PACK
cardgame.c:      || obj->item_type == ITEM_MONEY || obj->item_type == ITEM_GEM
cardgame.c:      || obj->item_type == ITEM_JEWELRY
cardgame.c:      || obj->item_type == ITEM_CLAN_DONATION
cardgame.c:      || obj->item_type == ITEM_PLAYER_DONATION
cardgame.c:      || obj->item_type == ITEM_BINDER)
cardgame.c:  if (obj->item_type == ITEM_QUIVER)
cardgame.c:  for (obj = obj->contains; obj != NULL; obj = obj->next_content)
cardgame.c:      if (obj == obj->next_content)
chant.c:	    obj = get_obj_list (ch, chant_target_name, obj->contains);
chant.c:	  obj->value[5]--;
chant.c:	  if (obj->value[5] <= 0 && obj->in_room)
chant.c:	      if (obj->in_room->people)
chant.c:		      obj->in_room->people, NULL, NULL, TO_ALL);
chant.c:          obj->value[5]--;
chant.c:          if (obj->value[5] <= 0 && obj->in_room)
chant.c:              if (obj->in_room->people)
chant.c:                      obj->in_room->people, NULL, NULL, TO_ALL);
chant.c:	          obj->value[5]--;
chant.c:          if (obj->value[5] <= 0 && obj->in_room)
chant.c:              if (obj->in_room->people)
chant.c:                      obj->in_room->people, NULL, NULL, TO_ALL);
chant.c:  obj->extra_flags[0] |= ITEM_ROT_DEATH;
chant.c:  if (obj->item_type != ITEM_WEAPON)
chant.c:  for (obj = object_list;obj != NULL;obj = obj->next)
chant.c:      if (obj->pIndexData->vnum == OBJ_VNUM_CORPSE_PC)
chant.c:	  if (!str_cmp(buf,obj->short_descr))
chant.c:  if (obj == NULL || obj->timer < 4 || victim->pcdata->corpse != NULL || obj->carried_by || (obj->in_room == NULL))
chant.c:  if (obj->in_room && obj->in_room->people)
chant.c:    act ("$p rises from the ground and stumbles away.",obj->in_room->people,obj,NULL,TO_ALL);
chant.c:  obj->timer = ch->level/10;
chant.c:  for (obj2 = obj->contains;obj2 != NULL;obj2 = obj2->next_content)
chant.c:  for (obj2 = obj->contains;obj2 != NULL;obj2 = obj2->next_content)
chant.c:  if (obj->carried_by)
chant.c:      for (prev = obj->contains; prev != NULL; prev = prev_next)
chant.c:          obj_to_room(prev,obj->carried_by->in_room);
chant.c:          sprintf (buf, "$p falls from %s.", obj->short_descr);
chant.c:      for (prev = obj->contains; prev != NULL; prev = prev_next)
chant.c:          obj_to_room(prev,obj->in_room);
chant.c:          sprintf (buf, "$p falls from %s.", obj->short_descr);
chant.c:  if (count_users (obj) >= obj->value[0])
chant.c:		  obj->in_room->people, NULL, NULL, TO_ALL);
chant.c:  for (obj2 = obj->contains;obj2 != NULL;obj2 = obj2->next_content)
chant.c:      for (obj = object_list;obj != NULL;obj = obj->next)
chant.c:	  if (obj->pIndexData->vnum == OBJ_VNUM_DARK_SPHERE)
chant.c:	      if (!str_cmp(obj->plr_owner,ch->name))
chant.c:  obj->plr_owner = str_dup(ch->name);
chant.c:  obj->value[0] = ch->in_room->vnum;   //For redundancy, may not use it
chant.c:  obj->timer = 10;
chaosjester.c:  if (obj->item_type != ITEM_CARD)
chaosjester.c:  for (tobj = ch->carrying; tobj; tobj = tobj->next_content)
chaosjester.c:      if ((tobj->wear_loc == WEAR_WIELD_R)
chaosjester.c:          || (tobj->wear_loc == WEAR_WIELD_L) || (tobj->wear_loc ==
chaosjester.c:          || (tobj->wear_loc == WEAR_SHIELD))
chaosjester.c:          if ((tobj->item_type == ITEM_WEAPON
chaosjester.c:              || (tobj->item_type == ITEM_INSTRUMENT
chaosjester.c:                  && IS_SET (tobj->value[0], A)))
chaosjester.c:  for (tobj = ch->carrying; tobj; tobj = tobj->next_content)
chaosjester.c:      if ((tobj->wear_loc == WEAR_WIELD_R)
chaosjester.c:          || (tobj->wear_loc == WEAR_WIELD_L) || (tobj->wear_loc ==
chaosjester.c:          || (tobj->wear_loc == WEAR_SHIELD))
chaosjester.c:          if ((tobj->item_type == ITEM_WEAPON
chaosjester.c:              || (tobj->item_type == ITEM_INSTRUMENT
chaosjester.c:                  && IS_SET (tobj->value[0], A)))
chaosjester.c:      obj_next = obj->next_content;
chaosjester.c:      if (obj->item_type != ITEM_CARD)
chaosjester.c:	  obj_next = obj->next_content;
chaosjester.c:      if (WEIGHT_MULT (obj) != 100 || obj->item_type == ITEM_QUIVER || WEIGHT_MULTP (obj) != 100)
chaosjester.c:          if (obj->item_type != ITEM_WEAPON || obj->value[0] != WEAPON_ARROW)
chaosjester.c:                    obj_next = obj->next_content;
comm.c:			obj_next = obj->next_content;
comm.c:			if (IS_CLASS(ch,PC_CLASS_REAVER) && (obj->wear_loc == WEAR_WIELD_L || obj->wear_loc == WEAR_WIELD_R))
comm.c:			if (obj->wear_loc != WEAR_NONE)
comm.c:			obj_next = obj->next_content;
comm.c: 			obj_next = obj->next_content;
comm.c:			obj_next = obj->next_content;
comm.c:	for (pobj = ch->carrying;pobj != NULL; pobj = pobj->next_content)
comm.c:	  if (pobj->contains != NULL)
comm.c:	    for (obj = pobj->contains; obj != NULL;obj = obj->next_content)
comm.c:		if (obj->item_type == ITEM_CARD)
comm.c:		    if (obj->pIndexData->vnum == OBJ_VNUM_COMMON_CARD)
comm.c:		    if (obj->value[8] > i)
comm.c:			obj->value[9] = obj->value[8]-i;
comm.c:			obj->value[8] = i;
comm.c:		    if (obj->value[9] > i)
comm.c:			obj->value[8] = obj->value[9]-i;
comm.c:			obj->value[9] = i;
comm.c:	  if (pobj->item_type == ITEM_CARD)
comm.c:	      if (pobj->pIndexData->vnum == OBJ_VNUM_COMMON_CARD)
comm.c:	      if (pobj->value[8] > i)
comm.c:		  pobj->value[9] = pobj->value[8]-i;
comm.c:		  pobj->value[8] = i;
comm.c:	      if (pobj->value[9] > i)
comm.c:		  pobj->value[8] = pobj->value[9]-i;
comm.c:		  pobj->value[9] = i;
comm.c:		  && obj->item_type == ITEM_LIGHT && obj->value[2] != 0)
db.c:	  obj->cost = 0;
db.c:	  if ((obj->in_room == NULL && obj->carried_by == NULL)
db.c:						    obj->contains))
db.c:	      cobj = create_object (pObjIndex, number_fuzzy (obj->level));
db.c:	  obj->value[1] = obj->pIndexData->value[1];
db.c:	      SET_BIT (obj->extra_flags[0], ITEM_INVENTORY);
db.c:		  if (obj->level > mob->level + 19)
db.c:			     obj->short_descr, obj->pIndexData->vnum,
db.c:			     obj->level, mob->short_descr,
db.c:  obj->pIndexData = pObjIndex;
db.c:  obj->in_room = NULL;
db.c:  obj->enchanted = FALSE;
db.c:  obj->level = pObjIndex->level;
db.c:  obj->wear_loc = -1;
db.c:  obj->name = str_dup (pObjIndex->name);
db.c:  obj->short_descr = str_dup (pObjIndex->short_descr);
db.c:  obj->description = str_dup (pObjIndex->description);
db.c:  obj->timer = pObjIndex->timer;
db.c:    obj->material = str_dup (pObjIndex->material);
db.c:    obj->material = str_dup ("");
db.c:  obj->item_type = pObjIndex->item_type;
db.c:    obj->extra_flags[i] = pObjIndex->extra_flags[i];
db.c:  obj->wear_flags = pObjIndex->wear_flags;
db.c:  obj->Class_flags = pObjIndex->Class_flags;
db.c:  obj->race_flags = pObjIndex->race_flags;
db.c:  obj->clan_flags = pObjIndex->clan_flags;
db.c:      obj->objtrig[i] = new_ot(pObjIndex->obj_trig_vnum[i]);
db.c:      if (obj->objtrig[i])
db.c:        obj->objtrig[i]->obj_on = obj;
db.c:    else obj->objtrig[i] = NULL;
db.c:    obj->plr_owner = pObjIndex->plr_owner;
db.c:  else obj->plr_owner = str_dup(pObjIndex->plr_owner);;
db.c:  obj->condition = pObjIndex->condition;
db.c:  obj->value[0] = pObjIndex->value[0];
db.c:  obj->value[1] = pObjIndex->value[1];
db.c:  obj->value[2] = pObjIndex->value[2];
db.c:  obj->value[3] = pObjIndex->value[3];
db.c:  obj->value[4] = pObjIndex->value[4];
db.c:  obj->value[5] = pObjIndex->value[5];
db.c:  obj->value[6] = pObjIndex->value[6];
db.c:  if (obj->item_type == ITEM_CARD || obj->item_type == ITEM_ROOM_TRAP || obj->item_type == ITEM_OBJ_TRAP || obj->item_type == ITEM_PORTAL_TRAP )
db.c:    obj->value[7] = pObjIndex->value[7];
db.c:    obj->value[8] = pObjIndex->value[8];
db.c:    obj->value[9] = pObjIndex->value[9];
db.c:    obj->value[10] = pObjIndex->value[10];
db.c:    obj->value[11] = pObjIndex->value[11];
db.c:    obj->value[12] = pObjIndex->value[12];
db.c:  obj->weight = pObjIndex->weight;
db.c:  obj->dest_list = NULL;
db.c:  obj->cost = pObjIndex->cost;
db.c:  switch (obj->item_type)
db.c:	       pObjIndex->vnum, obj->item_type);
db.c:      if (obj->value[2] == 999)
db.c:	  obj->value[2] = -1;
db.c:	obj->value[i] = -1;
db.c:/*      if (obj->pIndexData->vnum == OBJ_VNUM_COMMON_CARD)
db.c:      if (obj->value[8] > i)
db.c:        obj->value[9] = obj->value[8]-i;
db.c:        obj->value[8] = i;
db.c:      if (obj->value[9] > i)
db.c:        obj->value[8] = obj->value[9]-i;
db.c:	obj->value[9] = i;
db.c:	obj->item_type = ITEM_ARMOR;
db.c:	  case 1: sprintf(buf2,"sword");obj->item_type = ITEM_WEAPON;obj->wear_flags = ITEM_WIELD;obj->value[0] = WEAPON_SWORD;break;
db.c:	  case 2: sprintf(buf2,"helmet");obj->wear_flags = ITEM_WEAR_HEAD;break;
db.c:	  case 3: sprintf(buf2,"bracer");obj->wear_flags = ITEM_WEAR_WRIST;break;
db.c:          case 4: sprintf(buf2,"ring");obj->wear_flags = ITEM_WEAR_FINGER;break;
db.c:	  case 5: sprintf(buf2,"necklace");obj->wear_flags = ITEM_WEAR_NECK;break;
db.c:	  case 6: sprintf(buf2,"set of leg guards");obj->wear_flags = ITEM_WEAR_LEGS;break;
db.c:	  case 7: sprintf(buf2,"pair of boots");obj->wear_flags = ITEM_WEAR_FEET;break;
db.c:	  case 8: sprintf(buf2,"pair of gloves");obj->wear_flags = ITEM_WEAR_HANDS;break;
db.c:	  case 9: sprintf(buf2,"cape");obj->wear_flags = ITEM_WEAR_ABOUT;break;
db.c:	  case 10: sprintf(buf2,"belt");obj->wear_flags = ITEM_WEAR_WAIST;break;
db.c:          case 11: sprintf(buf2,"gown");obj->wear_flags = ITEM_WEAR_ABOUT;break;
db.c:          case 12: sprintf(buf2,"breastplate");obj->wear_flags = ITEM_WEAR_BODY;break;
db.c:          default: sprintf(buf2,"pair of pants");obj->wear_flags = ITEM_WEAR_LEGS;break;
db.c:	obj->wear_flags += ITEM_TAKE;
db.c:	sprintf (buf,"%s %s",obj->name,buf2);
db.c:	free_string(obj->name);
db.c:	obj->name = str_dup(buf);
db.c:	free_string(obj->short_descr);
db.c:	obj->short_descr = str_dup(buf);
db.c:	obj->description = str_dup(capitalize(buf2));
db.c:	obj->cost = number_percent();
db.c:	obj->weight = number_range(0,100);
db.c:	obj->level = 20 + number_range(1,40);
db.c:	if (obj->item_type == ITEM_ARMOR)
db.c:  	  obj->value[0] = -10+number_range(1,20);
db.c:	  obj->value[1] = -10+number_range(1,20);
db.c:	  obj->value[2] = -10+number_range(1,20);
db.c:	  obj->value[3] = -10+number_range(1,20);
db.c:	else if (obj->item_type == ITEM_WEAPON)
db.c:	  obj->value[1] = -5 + number_range(1,10);
db.c:	  obj->value[2] = -5 + number_range(1,10);
db.c:	  obj->value[3] = number_range(0,39);
db.c:  if (obj->item_type == ITEM_ELEVATOR)
db.c:    if ((location = get_room_index (obj->value[0])) != NULL)
db.c:  if (obj->item_type == ITEM_CTRANSPORT)
db.c:    set_transport_flags (obj->value[2], obj->pIndexData->vnum);
db.c:  obj->extra_descr = NULL;
db.c:      ed_new->next = obj->extra_descr;
db.c:      obj->extra_descr = ed_new;
db.c:  obj->next = object_list;
db.c:  if ((obj->item_type == ITEM_CLAN_DONATION) ||
db.c:      (obj->item_type == ITEM_NEWCLANS_DBOX))
db.c:      if (obj->item_type == ITEM_PLAYER_DONATION)
db.c:  if (obj->rarity == RARITY_ALWAYS)
db.c:  switch (obj->rarity)
db.c:  base -= (obj->count * 2);
db.c:  switch (obj->rarity)
db.c:  for (obj = object_list; obj != NULL; obj = obj->next)
db.c:      for (af = obj->affected; af != NULL; af = af->next)
db.c:  for (obj = obj_free; obj != NULL; obj = obj->next)
Druid.c:        obj_next = obj->next_content;
Druid.c:        if (obj->wear_loc != WEAR_NONE)
Druid.c:	if (obj != NULL && obj->pIndexData->vnum == OBJ_VNUM_SHILLELAGH)
Druid.c:	for (obj = ch->in_room->contents; obj != NULL; obj = obj->next_content) {
Druid.c:		if ((obj->item_type == ITEM_TREE) && !IS_SET(obj->value[4], TREE_VALUE_FALLEN) &&
Druid.c:			!IS_SET(obj->value[4], TREE_VALUE_ROTTEN) && can_see_obj(ch, obj)) {
Druid.c:    for (obj = room->contents; obj != NULL; obj = obj->next_content) {    
Druid.c:        if (obj->item_type == ITEM_TREE)
Druid.c:    for (obj = ch->carrying; obj != NULL; obj = obj->next_content) {
Druid.c:        if (obj->pIndexData->vnum == OBJ_VNUM_SHILLELAGH) {
Druid.c:    for (obj = ch->on; obj != NULL; obj = obj->next_content) {
Druid.c:        if (obj->pIndexData->vnum == OBJ_VNUM_SHILLELAGH) {
Druid.c:    for (obj = ch->in_room->contents; obj != NULL; obj = obj->next_content) {    
Druid.c:        if ((obj->item_type == ITEM_TREE) && !IS_SET(obj->value[4],TREE_VALUE_FALLEN) && 
Druid.c:            !IS_SET(obj->value[4],TREE_VALUE_ROTTEN) && can_see_obj(ch, obj)) {
Druid.c:    for (obj = ch->in_room->contents; obj != NULL; obj = obj->next_content) {    
Druid.c:        if ((obj->item_type == ITEM_TREE) && !IS_SET(obj->value[4],TREE_VALUE_FALLEN) && 
Druid.c:            !IS_SET(obj->value[4],TREE_VALUE_ROTTEN) && can_see_obj(ch, obj)) {
Druid.c:        if ((obj->item_type) && !((obj->item_type == ITEM_WEAPON) || (obj->item_type == ITEM_ARMOR) || (obj->item_type == ITEM_CLOTHING))) {
Druid.c:                obj->extra_flags[0] |= ITEM_NONMETAL;
Druid.c:                if (obj->extra_flags[0] & ITEM_BURN_PROOF)
Druid.c:                    obj->extra_flags[0] ^= ITEM_BURN_PROOF;
Druid.c:                free_string(obj->material);
Druid.c:                obj->material = str_dup("wood");                    
Druid.c:                strcpy(buf, obj->short_descr);
Druid.c:                free_string(obj->short_descr);
Druid.c:                obj->short_descr = str_dup(buf2);
Druid.c:                strcpy(buf, obj->description);
Druid.c:                free_string(obj->description);
Druid.c:                obj->description = str_dup(buf2);
Druid.c:                sprintf(buf, "Brown fumes engulf %s.\n\r", obj->short_descr);
Druid.c:                sprintf(buf, "Brown fumes evaporate %s.\n\r", obj->short_descr);
effects.c:	  obj_next = obj->next_content;
effects.c:	  obj_next = obj->next_content;
effects.c:      if (IS_OBJ_STAT (obj, ITEM_BURN_PROOF) || IS_SET(obj->extra_flags[1],ITEM_ACID_PROOF)
effects.c:      chance -= obj->level * 2;
effects.c:      switch (obj->item_type)
effects.c:      if (obj->carried_by != NULL)
effects.c:	act (msg, obj->carried_by, obj, NULL, TO_ALL);
effects.c:      else if (obj->in_room != NULL && obj->in_room->people != NULL)
effects.c:	act (msg, obj->in_room->people, obj, NULL, TO_ALL);
effects.c:      if (obj->item_type == ITEM_ARMOR)
effects.c:	  for (paf = obj->affected; paf != NULL; paf = paf->next)
effects.c:	      paf->next = obj->affected;
effects.c:	      obj->affected = paf;
effects.c:	  if (obj->carried_by != NULL && obj->wear_loc != WEAR_NONE)
effects.c:	      obj->carried_by->armor[i] += 1;
effects.c:      if (obj->contains)
effects.c:	  for (t_obj = obj->contains; t_obj != NULL; t_obj = n_obj)
effects.c:	      n_obj = t_obj->next_content;
effects.c:	      if (obj->in_room != NULL)
effects.c:		obj_to_room (t_obj, obj->in_room);
effects.c:	      else if (obj->carried_by != NULL)
effects.c:		obj_to_room (t_obj, obj->carried_by->in_room);
effects.c:	  obj_next = obj->next_content;
effects.c:	      obj_next = obj->next_content;
effects.c:      if (IS_OBJ_STAT (obj, ITEM_BURN_PROOF) || IS_SET(obj->extra_flags[1],ITEM_COLD_PROOF)
effects.c:      chance -= obj->level * 2;
effects.c:      switch (obj->item_type)
effects.c:      if (obj->carried_by != NULL)
effects.c:	act (msg, obj->carried_by, obj, NULL, TO_ALL);
effects.c:      else if (obj->in_room != NULL && obj->in_room->people != NULL)
effects.c:	act (msg, obj->in_room->people, obj, NULL, TO_ALL);
effects.c:	      obj_next = obj->next_content;
effects.c:	      obj_next = obj->next_content;
effects.c:      chance -= obj->level * 2;
effects.c:      switch (obj->item_type)
effects.c:      if (obj->carried_by != NULL)
effects.c:	act (msg, obj->carried_by, obj, NULL, TO_ALL);
effects.c:      else if (obj->in_room != NULL && obj->in_room->people != NULL)
effects.c:	act (msg, obj->in_room->people, obj, NULL, TO_ALL);
effects.c:      if (obj->contains)
effects.c:	  for (t_obj = obj->contains; t_obj != NULL; t_obj = n_obj)
effects.c:	      n_obj = t_obj->next_content;
effects.c:	      if (obj->in_room != NULL)
effects.c:		obj_to_room (t_obj, obj->in_room);
effects.c:	      else if (obj->carried_by != NULL)
effects.c:		obj_to_room (t_obj, obj->carried_by->in_room);
effects.c:	  obj_next = obj->next_content;
effects.c:	  obj_next = obj->next_content;
effects.c:      chance -= obj->level * 2;
effects.c:      switch (obj->item_type)
effects.c:	  if (obj->value[0] == obj->value[1])
effects.c:      obj->value[3] = 1;
effects.c:	      obj_next = obj->next_content;
effects.c:	      obj_next = obj->next_content;
effects.c:      if (IS_OBJ_STAT (obj, ITEM_BURN_PROOF) || IS_SET(obj->extra_flags[1],ITEM_LIGHTNING_PROOF)
effects.c:      chance -= obj->level * 2;
effects.c:      switch (obj->item_type)
effects.c:      if (obj->carried_by != NULL)
effects.c:	act (msg, obj->carried_by, obj, NULL, TO_ALL);
effects.c:      else if (obj->in_room != NULL && obj->in_room->people != NULL)
effects.c:	act (msg, obj->in_room->people, obj, NULL, TO_ALL);
fight.c:  for (pit_obj = object_list; pit_obj; pit_obj = pit_obj->next)
fight.c:  if (pit_obj->pIndexData->vnum == OBJ_VNUM_PIT)
fight.c:  pit_obj->in_room->people, NULL, ch, TO_ALL);
fight.c:  obj_next = obj->next_content;
fight.c:    if (IS_SET (weapon_obj->value[4], WEAPON_TWO_HANDS) && (ch->race != PC_RACE_VROATH))
fight.c:  for (obj = ch->carrying; obj; obj = obj->next_content)
fight.c:    if (obj->item_type != ITEM_WEAPON)
fight.c:    if (IS_SET (obj->value[4], WEAPON_THROWING))
fight.c:      do_throw (ch, obj->name);
fight.c:        obj->extra_flags[0] |= ITEM_NODROP | ITEM_NOUNCURSE;
fight.c:        free_string (obj->name);
fight.c:        obj->name = str_dup (buf);
fight.c:        sprintf (buf, obj->short_descr, name);
fight.c:        free_string (obj->short_descr);
fight.c:        obj->short_descr = str_dup (buf);
fight.c:        sprintf (buf, obj->description, name);
fight.c:        free_string (obj->description);
fight.c:        obj->description = str_dup (buf);
fight.c:    obj_next = obj->next_content;
fight.c:    if (IS_SET(obj->extra_flags[1],ITEM_TATTOO))
fight.c:    //      if (IS_SET(obj->wear_loc,WEAR_FLOAT))
fight.c:    if (obj->item_type == ITEM_POTION)
fight.c:      obj->timer = number_range (500, 1000);
fight.c:    if (obj->item_type == ITEM_SCROLL)
fight.c:      obj->timer = number_range (1000, 2500);
fight.c:    if (!IS_NPC (ch) && IS_SET (obj->extra_flags[0], ITEM_ROT_DEATH))
fight.c:    if (IS_SET (obj->extra_flags[0], ITEM_VIS_DEATH))
fight.c:      REMOVE_BIT (obj->extra_flags[0], ITEM_VIS_DEATH);
fight.c:    if (IS_SET (obj->extra_flags[0], ITEM_INVENTORY))
fight.c:    robj->value[3] = number_range(1,30000);
fight.c:    if (obj->item_type != ITEM_GEM && obj->item_type != ITEM_TREASURE && obj->item_type != ITEM_FEATHER)
fight.c:      obj->timer = number_range (4, 7);
fight.c:    sprintf (buf, obj->short_descr, name);
fight.c:    free_string (obj->short_descr);
fight.c:    obj->short_descr = str_dup (buf);
fight.c:    sprintf (buf, obj->description, name);
fight.c:    free_string (obj->description);
fight.c:    obj->description = str_dup (buf);
fight.c:    if (obj->pIndexData->vnum == OBJ_VNUM_EYE)
fight.c:      sprintf(buf,"%s %s",obj->name,name);
fight.c:      free_string(obj->name);
fight.c:      obj->name = str_dup(buf);
fight.c:    if (obj->item_type == ITEM_FOOD)
fight.c:        obj->value[3] = 1;
fight.c:        obj->item_type = ITEM_TRASH;
fight.c:          for (tobj = binder->contains; tobj != NULL; tobj = tobj->next_content)
fight.c:          for (tobj = binder->contains; tobj != NULL; tobj = tobj->next_content)
fight.c:        obj_next = obj->next_content;
fight.c:        if (obj->wear_loc == WEAR_NONE)
fight.c:        wear_long = obj->wear_loc;
fight.c:        if (obj->affected)
fight.c:    obj_next = obj->next_content;
fight.c:          obj->value[11] = number_range(0,4);
fight.c:          obj->value[8] = number_range(0,value);
fight.c:          obj->value[9] = value - obj->value[8];
fight.c:          if (obj->value[9] > 9)
fight.c:            obj->value[8] += obj->value[9] - 9;
fight.c:            obj->value[9] = 9;
fight.c:          if (obj->value[8] > 9)
fight.c:            value += obj->value[8] - 9;
fight.c:            obj->value[8] = 9;
fight.c:            obj->value[12] = number_range(1,9);
fight.c:          obj->value[7] = (victim->level/10) - 2;
fight.c:          if (obj->value[7] < 1)
fight.c:            obj->value[7] = 1; 
fight.c:            obj->value[10] = CARD_RACE_HUMANOID;
fight.c:            obj->value[10] = CARD_RACE_UNDEAD;
fight.c:            obj->value[10] = CARD_RACE_DRAGON;
fight.c:            obj->value[10] = CARD_RACE_MAGIC;
fight.c:            obj->value[10] = CARD_RACE_MONSTER;
fight.c:            obj->value[10] = CARD_RACE_BIRD;
fight.c:            obj->value[10] = CARD_RACE_INSECT;
fight.c:            obj->value[10] = CARD_RACE_FISH;
fight.c:          else obj->value[10] = CARD_RACE_ANIMAL;
fight.c:            obj->value[10] = CARD_RACE_UNDEAD;
fight.c:          switch (obj->value[11])
fight.c:          free_string(obj->short_descr);
fight.c:          obj->short_descr = str_dup(buf);
fight.c:          free_string(obj->name);
fight.c:          obj->name = str_dup(buf);
fight.c:      obj_next = obj->next_content;
fight.c:      if (obj->wear_loc == WEAR_NONE)
fight.c:  if (obj->item_type != ITEM_WEAPON)
fight.c:  for (tobj = ch->carrying; tobj; tobj = tobj->next_content)
fight.c:    if ((tobj->wear_loc == WEAR_WIELD_R)
fight.c:      || (tobj->wear_loc == WEAR_WIELD_L) || (tobj->wear_loc ==
fight.c:      || (tobj->wear_loc == WEAR_SHIELD))
fight.c:      if ((tobj->item_type == ITEM_WEAPON
fight.c:        || (tobj->item_type == ITEM_INSTRUMENT
fight.c:        && IS_SET (tobj->value[0], A)))
fight.c:  if (!IS_SET (obj->value[4], WEAPON_THROWING))
fight.c:  if (ch->level < (obj->level - EQUIP_LEVEL_DIFF))
fight.c:  for (obj = ch->carrying; obj != NULL; obj = obj->next_content)
fight.c:    if (is_name (argument, obj->name) && can_see_obj (ch, obj))
fight.c:  if (obj->item_type != ITEM_WEAPON)
fight.c:  for (tobj = ch->carrying; tobj; tobj = tobj->next_content)
fight.c:    if ((tobj->wear_loc == WEAR_HOLD
fight.c:      || tobj->wear_loc == WEAR_WIELD_R || tobj->wear_loc ==
fight.c:  if ((obj->value[3] != 11 && !IS_CLASS (ch, PC_CLASS_ASSASSIN))
fight.c:    || (obj->value[0] == WEAPON_ARROW))
fight.c:  if (obj->item_type != ITEM_CORPSE_NPC && obj->item_type != ITEM_CORPSE_PC)
fight.c:  if (obj->item_type == ITEM_CORPSE_PC)
fight.c:    strcpy(buf2,obj->short_descr);
fight.c:    for (objin = obj->contains; objin; objin = objnext)
fight.c:      sprintf (buf, "$p falls from %s.", obj->short_descr);
fight.c:          tobj_next = tobj->next_content;
fight.c:          switch (tobj->pIndexData->vnum)
fight.c:            silver += tobj->value[0];
fight.c:            gold += tobj->value[1];
fight.c:            silver += tobj->value[0];
fight.c:            gold += tobj->value[1];
fight.c:  if (skillper < 25 || obj->value[6] == SIZE_TINY)
fight.c:  else if (skillper < 50 || obj->value[6] == SIZE_SMALL)
fight.c:  for (objin = obj->contains; objin; objin = objnext)
fight.c:    sprintf (buf, "$p falls from %s.", obj->short_descr);
fight.c:        tobj_next = tobj->next_content;
fight.c:        switch (tobj->pIndexData->vnum)
fight.c:          silver += tobj->value[0];
fight.c:          gold += tobj->value[1];
fight.c:          silver += tobj->value[0];
fight.c:          gold += tobj->value[1];
fight.c:    one_argument (obj->name, buf);
fight.c:        obj->extra_flags[0] |= ITEM_NODROP | ITEM_NOUNCURSE;
fight.c:        free_string (obj->name);
fight.c:        obj->name = str_dup (buf);
fight.c:        sprintf (buf, obj->short_descr, name);
fight.c:        free_string (obj->short_descr);
fight.c:        obj->short_descr = str_dup (buf);
fight.c:        sprintf (buf, obj->description, name);
fight.c:        free_string (obj->description);
fight.c:        obj->description = str_dup (buf);
fishing.c:      obj->weight = ch->pcdata->fishing_weight * 10;
fishing.c:      obj->weight = ch->pcdata->fishing_weight * 10;
fishing.c:	  obj->cost = ch->pcdata->fishing_weight * 100;
fishing.c:	  obj->cost = ch->pcdata->fishing_weight * 100;
fishing.c:	  obj->cost = ch->pcdata->fishing_weight * 100;
fishing.c:	  obj->cost = 10 * ch->pcdata->fishing_weight * 100;
fishing.c:	  obj->cost = 10 * ch->pcdata->fishing_weight * 100;
fishing.c:	  obj->cost = 20 * ch->pcdata->fishing_weight * 100;
fishing.c:	  obj->cost = 1500000;
fishing.c:      free_string (obj->short_descr);
fishing.c:      obj->short_descr = str_dup (obj_name);
fishing.c:      free_string (obj->description);
fishing.c:      obj->description = str_dup (capitalize (obj_name));	//," is here.");
fishing.c:      free_string (obj->name);
fishing.c:      obj->name = str_dup (obj_keywords);
fishing.c:	   obj->short_descr, obj->weight / 10);
fishing.c:      if (!str_cmp(top_fishers[i].name,ch->name) && top_fishers[i].weight >= obj->weight / 10.0
fishing.c:		      && obj->weight < 2500)
fishing.c:	      if (obj->weight < 2500 && obj->cost > 10000)
fishing.c:		      obj->cost = 10000;
fishing.c:      if (top_fishers[i].weight < obj->weight / 10.0)
fishing.c:	  top_fishers[i].weight = obj->weight / 10.0;
fishing.c:	  strcpy (top_fishers[i].fish_name, obj->short_descr);
fishing.c:    if (obj->weight < 2500 && obj->cost > 10000)
fishing.c:      obj->cost = 10000;
gamble.c:  for (obj = object_list; obj; obj = obj->next)
gamble.c:      if (obj->pIndexData->vnum == OBJ_VNUM_ROULETTE)
handler.c:  if (obj->in_room == NULL)
handler.c:  for (fch = obj->in_room->people; fch != NULL; fch = fch->next_in_room)
handler.c:        REMOVE_BIT(wear_flags_left,obj->wear_loc);
handler.c:	  if (!obj->enchanted)
handler.c:	    for (af = obj->pIndexData->affected; af != NULL; af = af->next)
handler.c:	  for (af = obj->affected; af != NULL; af = af->next)
handler.c:      REMOVE_BIT(wear_flags_left,obj->wear_loc);
handler.c:      if (!obj->enchanted)
handler.c:	for (af = obj->pIndexData->affected; af != NULL; af = af->next)
handler.c:      for (af = obj->affected; af != NULL; af = af->next)
handler.c:  if (!obj->enchanted)
handler.c:      obj->enchanted = TRUE;
handler.c:      for (paf = obj->pIndexData->affected; paf != NULL; paf = paf->next)
handler.c:	  af_new->next = obj->affected;
handler.c:	  obj->affected = af_new;
handler.c:  for (obj = ch->carrying; obj != NULL; obj = obj->next_content)
handler.c:      if (obj->wear_loc == -1)
handler.c:      for (paf = obj->affected; paf != NULL; paf = paf->next)
handler.c:      if (obj->enchanted)
handler.c:      for (paf = obj->pIndexData->affected; paf != NULL; paf = paf->next)
handler.c:  paf_new->next = obj->affected;
handler.c:  obj->affected = paf_new;
handler.c:	SET_BIT (obj->extra_flags[0], paf->bitvector);
handler.c:	SET_BIT (obj->extra_flags[1], paf->bitvector);
handler.c:	if (obj->item_type == ITEM_WEAPON)
handler.c:	  SET_BIT (obj->value[4], paf->bitvector);
handler.c:	obj_next = obj->next_content;
handler.c:	if (obj->wear_loc == WEAR_NONE)
handler.c:	wear_long = obj->wear_loc;
handler.c://	if (obj->affected)
handler.c:  if (obj->affected == NULL)
handler.c:  if (obj->carried_by != NULL && obj->wear_loc != -1)
handler.c:    affect_modify (obj->carried_by, paf, FALSE);
handler.c:	REMOVE_BIT (obj->extra_flags[0], paf->bitvector);
handler.c:	REMOVE_BIT (obj->extra_flags[1], paf->bitvector);
handler.c:	if (obj->item_type == ITEM_WEAPON)
handler.c:	  REMOVE_BIT (obj->value[4], paf->bitvector);
handler.c:  if (paf == obj->affected)
handler.c:      obj->affected = paf->next;
handler.c:      for (prev = obj->affected; prev != NULL; prev = prev->next)
handler.c:  if (obj->carried_by != NULL && obj->wear_loc != -1)
handler.c:    affect_check (obj->carried_by, where, vector);
handler.c:      && obj->item_type == ITEM_LIGHT
handler.c:      && obj->value[2] != 0) || (!IS_NPC(ch) && ch->pcdata->flaming))
handler.c:                  && obj->item_type == ITEM_LIGHT
handler.c:	      && obj->value[2] != 0 && ch->in_room != NULL))
handler.c:      && obj->item_type == ITEM_LIGHT && obj->value[2] != 0)
handler.c:  if (!IS_NPC (ch) && obj->item_type == ITEM_FOOD && obj->timer == 0 && obj->value[5] != -1)
handler.c:    obj->timer = obj->pIndexData->value[2];
handler.c:  obj->next_content = ch->carrying;
handler.c:  obj->carried_by = ch;
handler.c:  obj->in_room = NULL;
handler.c:  obj->in_obj = NULL;
handler.c:  if ((ch = obj->carried_by) == NULL)
handler.c:  if (obj->wear_loc != WEAR_NONE)
handler.c:      ch->carrying = obj->next_content;
handler.c:	      prev->next_content = obj->next_content;
handler.c:  obj->carried_by = NULL;
handler.c:  obj->next_content = NULL;
handler.c:  if (obj->item_type != ITEM_ARMOR)
handler.c:  if (IS_SET(obj->wear_flags,ITEM_WEAR_BODY))
handler.c:    return 3 * obj->value[type];
handler.c:  if (IS_SET(obj->wear_flags,ITEM_WEAR_ABOUT) || IS_SET(obj->wear_flags,ITEM_WEAR_HEAD) 
handler.c:		  || IS_SET(obj->wear_flags,ITEM_WEAR_LEGS) || IS_SET(obj->wear_flags, ITEM_WEAR_LEGS))
handler.c:    return 2 * obj->value[type];
handler.c:  if (IS_SET(obj->wear_flags,ITEM_WEAR_FEET) || IS_SET(obj->wear_flags,ITEM_WEAR_HANDS)
handler.c:		  || IS_SET(obj->wear_flags,ITEM_WEAR_ARMS) || IS_SET(obj->wear_flags,ITEM_WEAR_SHIELD)
handler.c:		  || IS_SET(obj->wear_flags,ITEM_WEAR_NECK) || IS_SET(obj->wear_flags,ITEM_WEAR_ANOTHER_NECK)
handler.c:		  || IS_SET(obj->wear_flags,ITEM_WEAR_WRIST) || IS_SET(obj->wear_flags,ITEM_WEAR_ANOTHER_WRIST)
handler.c:		  || IS_SET(obj->wear_flags,ITEM_WEAR_WAIST) || IS_SET(obj->wear_flags,ITEM_HOLD)
handler.c:		  || IS_SET(obj->wear_flags,ITEM_WEAR_FACE))
handler.c:	  return obj->value[type];
handler.c:  if (obj->item_type != ITEM_ARMOR)
handler.c:      return 3 * obj->value[type];
handler.c:      return 2 * obj->value[type];
handler.c:      return 2 * obj->value[type];
handler.c:      return obj->value[type];
handler.c:      return obj->value[type];
handler.c:      return obj->value[type];
handler.c:      return obj->value[type];
handler.c:      return obj->value[type];
handler.c:      return obj->value[type];
handler.c:      return 2 * obj->value[type];
handler.c:      return obj->value[type];
handler.c:      return obj->value[type];
handler.c:      return obj->value[type];
handler.c:      return obj->value[type];
handler.c:	return 3 * obj->value[type];
handler.c:  for (obj = ch->carrying; obj != NULL; obj = obj->next_content)
handler.c:	  bug (obj->short_descr, 0);
handler.c:	  bug (obj->name, 0);
handler.c:      if (obj->wear_loc == -1)
handler.c:      if (IS_SET(obj->wear_loc,iWear))
handler.c:  for (obj = ch->carrying; obj != NULL; obj = obj->next_content)
handler.c:          bug (obj->short_descr, 0);
handler.c:          bug (obj->name, 0);
handler.c:      if (obj->wear_loc == -1)
handler.c:      if (IS_SET(obj->wear_loc,wear_flag))
handler.c:  for (obj = rid->contents;obj != NULL;obj = obj->next_content)
handler.c:    if (obj->pIndexData->vnum == vnum)
handler.c:  for (obj = ch->carrying;obj != NULL;obj = obj->next_content)
handler.c:      if (obj->pIndexData->vnum == vnum)
handler.c:  for (obj = rid->contains;obj != NULL;obj = obj->next_content)
handler.c:      if (obj->pIndexData->vnum == vnum)
handler.c:  if (!IS_SET(obj->clan_flags,flag_value(clan_flags, capitalize(get_clan_name_ch (ch)))))
handler.c:	  if (obj->clan_flags != 0)
handler.c:		  && !IS_SET(obj->clan_flags,CLAN_NONE))
handler.c:	   if (obj->clan_flags != 0)
handler.c:                  && !IS_SET(obj->clan_flags,CLAN_LONER))
handler.c:	   if (obj->clan_flags != 0)
handler.c:  if (obj->race_flags != 0)
handler.c:	  if (!IS_SET (obj->race_flags, RACE_HUMAN))
handler.c:	  if (!IS_SET (obj->race_flags, RACE_ELF))
handler.c:	  if (!IS_SET (obj->race_flags, RACE_DWARF))
handler.c:	  if (!IS_SET (obj->race_flags, RACE_CANTHI))
handler.c:	  if (!IS_SET (obj->race_flags, RACE_VROATH))
handler.c:	  if (!IS_SET (obj->race_flags, RACE_SYVIN))
handler.c:	  if (!IS_SET (obj->race_flags, RACE_SIDHE))
handler.c:	  if (!IS_SET (obj->race_flags, RACE_LITAN))
handler.c:	  if (!IS_SET (obj->race_flags, RACE_LICH))
handler.c:	  if (!IS_SET (obj->race_flags, RACE_NERIX))
handler.c:	  if (!IS_SET (obj->race_flags, RACE_SWARM))
handler.c:  if (obj->Class_flags != 0)
handler.c:      if (IS_SET (obj->Class_flags, CLASS_HERO) && !(ch->pcdata->hero))
handler.c:	  if (IS_SET (obj->extra_flags[0], ITEM_NOREMOVE) && !IS_IMMORTAL (ch))
handler.c:	  if (IS_SET (obj->extra_flags[0], ITEM_NOREMOVE) && !IS_IMMORTAL (ch))
handler.c:    if (IS_SET (obj->extra_flags[0], ITEM_NOREMOVE) && !IS_IMMORTAL (ch))
handler.c:      if (i == ITEM_WEAR_NECK && !IS_SET(obj->wear_flags,ITEM_WEAR_ANOTHER_NECK))
handler.c:      else if (i == ITEM_WEAR_FINGER && !IS_SET(obj->wear_flags,ITEM_WEAR_ANOTHER_FINGER))
handler.c:      else if (i == ITEM_WEAR_WRIST && !IS_SET(obj->wear_flags, ITEM_WEAR_ANOTHER_WRIST))
handler.c:      if (IS_SET (obj->extra_flags[0], ITEM_NOREMOVE) && !IS_IMMORTAL (ch))
handler.c:     if (IS_SET (obj->extra_flags[0], ITEM_NOREMOVE) && !IS_IMMORTAL (ch))
handler.c:    if (IS_SET (obj->extra_flags[0], ITEM_NOREMOVE) && !IS_IMMORTAL (ch))
handler.c:    if (obj->item_type == ITEM_INSTRUMENT && IS_SET (obj->value[0], A) && ch->size < SIZE_LARGE)
handler.c:    if (IS_SET (obj->extra_flags[0], ITEM_NOREMOVE) && !IS_IMMORTAL (ch))
handler.c:    if (IS_SET (obj->extra_flags[0], ITEM_NOREMOVE) && !IS_IMMORTAL (ch))
handler.c:       if (i == ITEM_WEAR_NECK && !IS_SET(obj->wear_flags,ITEM_WEAR_ANOTHER_NECK))
handler.c:       else if (i == ITEM_WEAR_FINGER && !IS_SET(obj->wear_flags,ITEM_WEAR_ANOTHER_FINGER))
handler.c:       else if (i == ITEM_WEAR_WRIST && !IS_SET(obj->wear_flags, ITEM_WEAR_ANOTHER_WRIST))
handler.c:      /*      if (IS_SET (obj->extra_flags[0], ITEM_NOREMOVE) && !IS_IMMORTAL (ch))
handler.c:	  if (i == ITEM_WEAR_NECK && !IS_SET(obj->wear_flags,ITEM_WEAR_ANOTHER_NECK))
handler.c:	  else if (i == ITEM_WEAR_FINGER && !IS_SET(obj->wear_flags,ITEM_WEAR_ANOTHER_FINGER))
handler.c:	  else if (i == ITEM_WEAR_WRIST && !IS_SET(obj->wear_flags, ITEM_WEAR_ANOTHER_WRIST))
handler.c:	  if (IS_SET (obj->extra_flags[0], ITEM_NOREMOVE) && !IS_IMMORTAL (ch))
handler.c:	      if (IS_SET (obj->extra_flags[0], ITEM_NOREMOVE) && !IS_IMMORTAL (ch))
handler.c:	    if (IS_SET (obj->extra_flags[0], ITEM_NOREMOVE) && !IS_IMMORTAL (ch))
handler.c:      if (IS_SET (obj->extra_flags[0], ITEM_NOREMOVE) && !IS_IMMORTAL (ch))
handler.c:	  if (i == ITEM_WEAR_NECK && !IS_SET(obj->wear_flags,ITEM_WEAR_ANOTHER_NECK))
handler.c:	  else if (i == ITEM_WEAR_FINGER && !IS_SET(obj->wear_flags,ITEM_WEAR_ANOTHER_FINGER))
handler.c:	  else if (i == ITEM_WEAR_WRIST && !IS_SET(obj->wear_flags, ITEM_WEAR_ANOTHER_WRIST))
handler.c:	  if (IS_SET (obj->extra_flags[0], ITEM_NOREMOVE) && !IS_IMMORTAL (ch))
handler.c:      if (obj->item_type == ITEM_WEAPON && IS_WEAPON_STAT(obj,WEAPON_HOLY_ACTIVATED))
handler.c:	REMOVE_BIT(obj->value[4],WEAPON_HOLY_ACTIVATED);
handler.c:      if (obj->item_type == ITEM_POLE)
handler.c:	obj->value[1] = 0;
handler.c:      if (i == ITEM_WIELD &&!IS_NPC(ch) && obj->item_type == ITEM_WEAPON && ch->size < SIZE_LARGE 
handler.c:      if (i == ITEM_TWO_HANDS && !IS_NPC(ch) && obj->item_type == ITEM_WEAPON && ch->size < SIZE_LARGE 
handler.c:      if (IS_SET (obj->extra_flags[0], ITEM_NOREMOVE) && !IS_IMMORTAL (ch))
handler.c:      if (IS_SET (obj->extra_flags[0], ITEM_NOREMOVE) && !IS_IMMORTAL (ch))
handler.c:      if (obj->item_type == ITEM_INSTRUMENT && IS_SET (obj->value[0], A) && ch->size < SIZE_LARGE)
handler.c:      if (IS_SET (obj->extra_flags[0], ITEM_NOREMOVE) && !IS_IMMORTAL (ch))
handler.c:      if (IS_SET (obj->extra_flags[0], ITEM_NOREMOVE) && !IS_IMMORTAL (ch))
handler.c:      || ((IS_SET(obj->extra_flags[1],ITEM_NOAVATAR)) && ch->race == PC_RACE_AVATAR)
handler.c:      || ((IS_SET(obj->extra_flags[1],ITEM_NOKALIAN)) && ch->race == PC_RACE_KALIAN))
handler.c:      obj->wear_loc = -1;
handler.c:		  obj->wear_loc = wear_conversion_table[i].wear_flag;
handler.c://  obj->wear_loc = iWear;
handler.c:  if (!obj->enchanted)
handler.c:    for (paf = obj->pIndexData->affected; paf != NULL; paf = paf->next)
handler.c:  for (paf = obj->affected; paf != NULL; paf = paf->next)
handler.c:  if ((obj->item_type == ITEM_LIGHT
handler.c:       && obj->value[2] != 0 && ch->in_room != NULL)
handler.c:		  || ((IS_SET(obj->extra_flags[1],ITEM_NOAVATAR)) && ch->race == PC_RACE_AVATAR)
handler.c:		  || ((IS_SET(obj->extra_flags[1],ITEM_NOKALIAN)) && ch->race == PC_RACE_KALIAN))
handler.c:      obj->wear_loc = -1;
handler.c://  obj->wear_loc = 0;
handler.c://  obj->wear_loc = iWear;
handler.c:  /*  obj->wear_loc = obj->wear_flags;
handler.c:  if (IS_SET(obj->wear_loc,ITEM_TAKE))
handler.c:    obj->wear_loc -= ITEM_TAKE;
handler.c:  if (IS_SET(obj->wear_loc,ITEM_NO_SAC))
handler.c:    obj->wear_loc -= ITEM_NO_SAC;
handler.c:  if (IS_SET(obj->wear_loc,ITEM_TWO_HANDS))
handler.c:  obj->wear_loc -= ITEM_TWO_HANDS;*/
handler.c:  //obj->wear_loc = iWear;
handler.c:  if (!obj->enchanted)
handler.c:    for (paf = obj->pIndexData->affected; paf != NULL; paf = paf->next)
handler.c:  for (paf = obj->affected; paf != NULL; paf = paf->next)
handler.c:  if ((obj->item_type == ITEM_LIGHT
handler.c:      && obj->value[2] != 0 && ch->in_room != NULL)
handler.c:      || ((IS_SET(obj->extra_flags[1],ITEM_NOAVATAR)) && ch->race == PC_RACE_AVATAR)
handler.c:      || ((IS_SET(obj->extra_flags[1],ITEM_NOKALIAN)) && ch->race == PC_RACE_KALIAN))
handler.c:      obj->wear_loc = -1;
handler.c:  obj->wear_loc = slot;
handler.c:  //  obj->wear_loc = 0;
handler.c:  //  obj->wear_loc = iWear;
handler.c:  /*  obj->wear_loc = obj->wear_flags;
handler.c:  if (IS_SET(obj->wear_loc,ITEM_TAKE))
handler.c:    obj->wear_loc -= ITEM_TAKE;
handler.c:  if (IS_SET(obj->wear_loc,ITEM_NO_SAC))
handler.c:    obj->wear_loc -= ITEM_NO_SAC;
handler.c:  if (IS_SET(obj->wear_loc,ITEM_TWO_HANDS))
handler.c:  obj->wear_loc -= ITEM_TWO_HANDS;*/
handler.c:  //obj->wear_loc = iWear;
handler.c:  if (!obj->enchanted)
handler.c:    for (paf = obj->pIndexData->affected; paf != NULL; paf = paf->next)
handler.c:  for (paf = obj->affected; paf != NULL; paf = paf->next)
handler.c:  if ((obj->item_type == ITEM_LIGHT
handler.c:       && obj->value[2] != 0 && ch->in_room != NULL)
handler.c:  if (!obj || obj->wear_loc == WEAR_NONE)
handler.c:  obj->wear_loc = -1;
handler.c:  if (!obj->enchanted)
handler.c:      for (paf = obj->pIndexData->affected; paf != NULL; paf = paf->next)
handler.c://  if (obj->enchanted)
handler.c:      for (paf = obj->affected; paf != NULL; paf = paf->next)
handler.c:  for (paf = obj->affected; paf != NULL; paf = paf->next)
handler.c:  if (((obj->item_type == ITEM_LIGHT
handler.c:      && obj->value[2] != 0 && ch->in_room != NULL) && !(!IS_NPC(ch) && ch->pcdata->flaming))
handler.c:  for (obj = list; obj != NULL; obj = obj->next_content)
handler.c:      if (obj->pIndexData == pObjIndex)
handler.c:  if ((in_room = obj->in_room) == NULL)
handler.c:	       obj->name, obj->short_descr);
handler.c:  if (!(obj->item_type == ITEM_RAFT && paddling))
handler.c:      in_room->contents = obj->next_content;
handler.c:	      prev->next_content = obj->next_content;
handler.c:  if (obj->pIndexData->vnum == OBJ_VNUM_PENTAGRAM)
handler.c:    for (prev = obj->contains; prev != NULL; prev = prev_next)
handler.c:      obj_to_room(prev,obj->in_room);
handler.c:  obj->in_room = NULL;
handler.c:  obj->next_content = NULL;
handler.c:  obj->next_content = pRoomIndex->contents;
handler.c:  obj->in_room = pRoomIndex;
handler.c:  obj->carried_by = NULL;
handler.c:  obj->in_obj = NULL;
handler.c:  obj->next_content = obj_to->contains;
handler.c:  obj->in_obj = obj_to;
handler.c:  obj->in_room = NULL;
handler.c:  obj->carried_by = NULL;
handler.c:    obj->cost = 0;
handler.c:	  if ((obj->item_type != ITEM_WEAPON
handler.c:	      || obj->value[0] != WEAPON_ARROW
handler.c:		  && (obj->item_type != ITEM_CARD || obj_to->item_type != ITEM_BINDER))
handler.c:  OBJ_DATA *pobj, *pobj_last=NULL;//, *pobj->next;
handler.c:    obj->next_content = NULL;
handler.c:      obj->bs_capacity[0] = 1;
handler.c:    else obj->bs_capacity[0] = pos;
handler.c:  else if (pobj->next_content == NULL || (pos == -1 && pobj->bs_capacity[0] != 1) || (pos != -1 && pobj->bs_capacity[0] >= pos))
handler.c:    if (pos == pobj->bs_capacity[0])
handler.c:    if (pobj->bs_capacity[0] == 1 || (pos != -1 && pobj->bs_capacity[0] < pos))
handler.c:      obj->next_content = pobj->next_content;
handler.c:      pobj->next_content = obj;
handler.c:        obj->bs_capacity[0] = 2; //Its now the second thing in the obj_to 
handler.c:      else obj->bs_capacity[0] = pos;
handler.c:/*      if (pos == -1 || pos < pobj->bs_capacity[0])
handler.c:        obj->next_content = pobj;
handler.c:          obj->bs_capacity[0] = 1;
handler.c:	else obj->bs_capacity[0] = pos;
handler.c:    for (pobj = obj_to->contains;pobj != NULL;pobj_last = pobj, pobj = pobj->next_content, ++counter)
handler.c:      if (pos != -1 && pobj->bs_capacity[0] == pos)
handler.c:      if ((pos != -1 && pobj->bs_capacity[0] > pos) ||
handler.c:          (pos == -1 && pobj->bs_capacity[0] != counter))
handler.c:        obj->next_content = pobj;
handler.c:    //    if (obj->next_content != NULL)
handler.c:	  obj->bs_capacity[0] = counter;
handler.c:	else obj->bs_capacity[0] = pos;
handler.c:      obj->next_content = NULL;
handler.c:        obj->bs_capacity[0] = counter;
handler.c:      else obj->bs_capacity[0] = pos;
handler.c://  obj->next_content = obj_to->contains;
handler.c:  obj->in_obj = obj_to;
handler.c:  obj->in_room = NULL;
handler.c:  obj->carried_by = NULL;
handler.c:    obj->cost = 0;
handler.c:          if ((obj->item_type != ITEM_WEAPON
handler.c:              || obj->value[0] != WEAPON_ARROW
handler.c:	      && (obj->item_type != ITEM_CARD || obj_to->item_type != ITEM_BINDER))
handler.c:  if ((obj_from = obj->in_obj) == NULL)
handler.c:      obj_from->contains = obj->next_content;
handler.c:	      prev->next_content = obj->next_content;
handler.c:  obj->next_content = NULL;
handler.c:  obj->in_obj = NULL;
handler.c:	  if ((obj->item_type != ITEM_WEAPON || obj->value[0] != WEAPON_ARROW || obj_from->item_type != ITEM_QUIVER) &&
handler.c:	     (obj->item_type != ITEM_CARD || obj_from->item_type != ITEM_BINDER))
handler.c:  if (obj->set_by != NULL)
handler.c:	if (obj == obj->set_by->trap_list)
handler.c:      		obj->set_by->trap_list = obj->next_trap;
handler.c:      		for (prev = obj->set_by->trap_list; prev != NULL; prev = prev->next_trap)
handler.c:		        	prev->next_trap = obj->next_trap;
handler.c:  if (obj->item_type == ITEM_PORTAL
handler.c:      && obj->value[3] >= ROOM_VNUM_HAVEN_START
handler.c:      && obj->value[3] <= ROOM_VNUM_HAVEN_END)
handler.c:      location = get_room_index (obj->value[3]);
handler.c:	      char_to_room (vch, obj->in_room);
handler.c:	      dobj_next = dobj->next_content;
handler.c:  if (obj->pIndexData->vnum == OBJ_VNUM_BEACON)
handler.c:  if (obj->pIndexData->vnum == OBJ_VNUM_DARK_SPHERE)
handler.c:    rid = get_room_index(obj->value[0]);
handler.c://	    sprintf(buf,"%d",obj->value[0]);
handler.c:  if (obj->pIndexData->vnum == OBJ_VNUM_DEFILE)
handler.c:	  rid = get_room_index(obj->value[0]);
handler.c:	    rid->sector_type = obj->value[1];
handler.c:  if (obj->pIndexData->vnum == OBJ_VNUM_WARPED_SPACE)
handler.c:     rid = get_room_index(obj->value[0]);
handler.c: //      sprintf(buf,"%d",obj->value[0]);
handler.c:  if (obj->item_type == ITEM_WOODEN_INCONSTRUCTION)
handler.c:  if (obj->in_room != NULL)
handler.c:  else if (obj->carried_by != NULL)
handler.c:  else if (obj->in_obj != NULL)
handler.c:  for (obj_content = obj->contains; obj_content; obj_content = obj_next)
handler.c:  if (obj->pIndexData->vnum == OBJ_VNUM_CORPSE_PC)
handler.c:  if (obj->in_room != NULL)
handler.c:  else if (obj->carried_by != NULL)
handler.c:  else if (obj->in_obj != NULL)
handler.c:      object_list = obj->next;
handler.c:	      prev->next = obj->next;
handler.c:	  bug ("Extract_obj: obj %d not found.", obj->pIndexData->vnum);
handler.c:  --obj->pIndexData->count;
handler.c:      obj_next = obj->next_content;
handler.c:      if (!(!IS_NPC(ch) && fPull == FALSE && IS_SET(obj->extra_flags[1],ITEM_TATTOO)))
handler.c:  for (obj = object_list; obj != NULL; obj = obj->next)
handler.c:      if (obj->pIndexData == pObjIndex)
handler.c:  for (obj = list; obj != NULL; obj = obj->next_content)
handler.c:      if (can_see_obj (ch, obj) && is_name (arg, obj->name))
handler.c:  for (obj = ch->carrying; obj != NULL; obj = obj->next_content)
handler.c:      if (obj->wear_loc == WEAR_NONE
handler.c:	  && (can_see_obj (ch, obj)) && is_name (arg, obj->name))
handler.c:  for (obj = ch->carrying; obj != NULL; obj = obj->next_content)
handler.c:      if (obj->wear_loc != WEAR_NONE
handler.c:	  && can_see_obj (ch, obj) && is_name (arg, obj->name))
handler.c:  for (obj = object_list; obj != NULL; obj = obj->next)
handler.c:      if (can_see_obj (ch, obj) && is_name (arg, obj->name))
handler.c:      sprintf (buf, obj->short_descr, gold);
handler.c:      free_string (obj->short_descr);
handler.c:      obj->short_descr = str_dup (buf);
handler.c:      obj->value[1] = gold;
handler.c:      obj->cost = gold;
handler.c:      obj->weight = gold / 5;
handler.c:      sprintf (buf, obj->short_descr, silver);
handler.c:      free_string (obj->short_descr);
handler.c:      obj->short_descr = str_dup (buf);
handler.c:      obj->value[0] = silver;
handler.c:      obj->cost = silver;
handler.c:      obj->weight = silver / 20;
handler.c:      sprintf (buf, obj->short_descr, silver, gold);
handler.c:      free_string (obj->short_descr);
handler.c:      obj->short_descr = str_dup (buf);
handler.c:      obj->value[0] = silver;
handler.c:      obj->value[1] = gold;
handler.c:      obj->cost = 100 * gold + silver;
handler.c:      obj->weight = gold / 5 + silver / 20;
handler.c:  if (obj->item_type == ITEM_CONTAINER || obj->item_type == ITEM_PACK
handler.c:      || obj->item_type == ITEM_MONEY || obj->item_type == ITEM_GEM
handler.c:      || obj->item_type == ITEM_JEWELRY
handler.c:      || obj->item_type == ITEM_CLAN_DONATION
handler.c:      || obj->item_type == ITEM_PLAYER_DONATION
handler.c:      || obj->item_type == ITEM_BINDER)
handler.c:  if (obj->item_type == ITEM_QUIVER)
handler.c:  if (obj->item_type == ITEM_BINDER)
handler.c:  for (obj = obj->contains; obj != NULL; obj = obj->next_content)
handler.c:      if (obj == obj->next_content)
handler.c:  weight = obj->weight;
handler.c:  if (IS_SET(obj->extra_flags[1],ITEM_WINGED))
handler.c:  if (obj->item_type == ITEM_BINDER || obj->item_type == ITEM_QUIVER)
handler.c:  for (tobj = obj->contains; tobj != NULL; tobj = tobj->next_content)
handler.c:  weight = obj->weight;
handler.c:  if (IS_SET(obj->extra_flags[1],ITEM_WINGED))
handler.c:  if (obj->item_type == ITEM_BINDER || obj->item_type == ITEM_QUIVER)
handler.c:  for (obj = obj->contains; obj != NULL; obj = obj->next_content)
handler.c:  if ((!IS_IMMORTAL (ch) || (IS_NPC(ch) && ch->pIndexData->vnum == MOB_VNUM_FAKIE))&& IS_SET (obj->extra_flags[1],ITEM_WIZI))
handler.c:  if ((IS_IMMORTAL (ch) || ch->Class == PC_CLASS_CHAOS_JESTER || (IS_NPC(ch) && ch->pIndexData->pShop)) && IS_SET (obj->extra_flags[1],ITEM_IMAGINARY))
handler.c:  if (!IS_IMMORTAL(ch) && ch->Class != PC_CLASS_CHAOS_JESTER && IS_SET (obj->extra_flags[1],ITEM_IMAGINARY))
handler.c:  if (IS_SET (obj->extra_flags[0], ITEM_VIS_DEATH))
handler.c:  if (IS_SET (obj->extra_flags[1], ITEM_PULSATING))
handler.c:  if (IS_AFFECTED (ch, AFF_BLIND) && obj->item_type != ITEM_POTION)
handler.c:  if (obj->item_type == ITEM_LIGHT && obj->value[2] != 0)
handler.c:  if (IS_SET (obj->extra_flags[0], ITEM_INVIS)
handler.c:  if (!IS_SET (obj->extra_flags[0], ITEM_NODROP))
handler.c:  switch (obj->item_type)
handler.c:  bug ("Item_type_name: unknown type %d.", obj->item_type);
handler.c:      (obj->Class_flags,
handler.c:       (obj->Class_flags,
handler.c:       (obj->Class_flags,
handler.c:  if (obj->level - EQUIP_LEVEL_DIFF <= counter1)
handler.c://  if (obj->level - EQUIP_LEVEL_DIFF <= 60 && counter1 >= 2)
handler.c:  //if (obj->level - EQUIP_LEVEL_DIFF <= 90 && counter1 >= 3)
handler.c:  if (obj && obj->item_type == ITEM_INSTRUMENT && IS_SET (obj->value[0], A) && ch->size < SIZE_LARGE) 
handler.c:  if (IS_SET(obj->wear_flags,ITEM_WEAR_SHIELD))
handler.c:  if (IS_SET(obj->wear_flags,ITEM_HOLD))
handler.c:  if (obj->item_type == ITEM_INSTRUMENT && IS_SET (obj->value[0], A) && ch->size < SIZE_LARGE)
handler.c:  if (IS_SET(obj->wear_flags,ITEM_WIELD))
handler.c:  if (!IS_NPC(ch) && obj->item_type == ITEM_WEAPON && ch->size < SIZE_LARGE && IS_WEAPON_STAT (obj, WEAPON_TWO_HANDS))
handler.c:  /*  if (IS_SET(obj->wear_flags,ITEM_TWO_HANDS))
magic2.c:	          && obj->item_type == ITEM_LIGHT
magic2.c:	          && obj->value[2] != 0 && ch->in_room != NULL))
magic2.c:	       && obj->item_type == ITEM_LIGHT
magic2.c:               && obj->value[2] != 0 && ch->in_room != NULL))
magic2.c:	      obj_next = obj->next_content;
magic2.c:	      switch (obj->item_type)
magic2.c:	      if (obj->carried_by != NULL)
magic2.c:		act (msg, obj->carried_by, obj, NULL, TO_ALL);
magic2.c:	      else if (obj->in_room != NULL && obj->in_room->people != NULL)
magic2.c:		act (msg, obj->in_room->people, obj, NULL, TO_ALL);
magic2.c:	      if (obj->contains)
magic2.c:		  for (t_obj = obj->contains; t_obj != NULL; t_obj = n_obj)
magic2.c:		      n_obj = t_obj->next_content;
magic2.c:		      if (obj->in_room != NULL)
magic2.c:			obj_to_room (t_obj, obj->in_room);
magic2.c:		      else if (obj->carried_by != NULL)
magic2.c:			obj_to_room (t_obj, obj->carried_by->in_room);
magic2.c:  sprintf(buf,obj->description,(char*)vo);
magic2.c:  free_string(obj->description);
magic2.c:  obj->description = str_dup(buf);
magic2.c:  obj->timer = number_range(1,ch->level);
magic2.c:      for (obj = object_list;obj != NULL;obj = obj->next)
magic2.c:          if (obj->pIndexData->vnum == OBJ_VNUM_WARPED_SPACE)
magic2.c:              if (!str_cmp(obj->plr_owner,ch->name))
magic2.c:  obj->plr_owner = str_dup(ch->name);
magic2.c:  obj->value[0] = ch->in_room->vnum;   //For redundancy, may not use it
magic2.c:  obj->timer = 4;
magic2.c:      obj_next = obj->next_content;
magic2.c:      vnum = obj->pIndexData->vnum;
magic2.c:  obj->item_type = ITEM_ARMOR;
magic2.c:      obj->wear_flags = ITEM_WEAR_FINGER;
magic2.c:      obj->wear_flags = ITEM_WEAR_NECK;
magic2.c:      obj->wear_flags = ITEM_WEAR_BODY;
magic2.c:      obj->wear_flags = ITEM_WEAR_HEAD;
magic2.c:      obj->wear_flags = ITEM_WEAR_LEGS;
magic2.c:      obj->wear_flags = ITEM_WEAR_FEET;
magic2.c:      obj->wear_flags = ITEM_WEAR_HANDS;
magic2.c:      obj->wear_flags = ITEM_WEAR_ARMS;
magic2.c:      obj->wear_flags = ITEM_WEAR_SHIELD;
magic2.c:      obj->wear_flags = ITEM_WEAR_ABOUT;
magic2.c:      obj->wear_flags = ITEM_WEAR_WAIST;
magic2.c:      obj->wear_flags = ITEM_WEAR_WRIST;
magic2.c:      obj->wear_flags = ITEM_HOLD;
magic2.c:      obj->wear_flags = ITEM_WEAR_FACE;
magic2.c:      obj->wear_flags = ITEM_WEAR_FLOATING;
magic2.c:      obj->item_type = ITEM_LIGHT;
magic2.c:    obj->item_type = ITEM_WEAR_CLAN_MARK;
magic2.c:  obj->wear_flags |= ITEM_TAKE;
magic2.c:  if (obj->item_type == ITEM_ARMOR)
magic2.c:      obj->value[0] = 4;
magic2.c:      obj->value[1] = 4;
magic2.c:      obj->value[2] = 4;
magic2.c:      obj->value[3] = 4;
magic2.c:  free_string(obj->short_descr);
magic2.c:  obj->short_descr = str_dup(argument);
magic2.c:  free_string(obj->name);
magic2.c:  obj->name = str_dup(buf);
magic2.c:  if (obj->plr_owner != NULL)
magic2.c:    free_string(obj->plr_owner);
magic2.c:  obj->plr_owner = str_dup(ch->name);
magic2.c:      obj_next = obj->next_content;
magic2.c:      if (!IS_SET(obj->wear_flags,ITEM_TAKE))
magic2.c:      if (IS_SET(obj->extra_flags[1],ITEM_WIZI) && !IS_IMMORTAL(ch))
magic2.c:      if (!obj->in_room)
magic2.c:      for (gch = obj->in_room->people; gch != NULL; gch = gch->next_in_room)
magic2.c:      if ((!obj->in_obj || obj->in_obj->carried_by != ch)
magic2.c:      if (IS_SET(obj->extra_flags[0],ITEM_NOMOB) && IS_NPC(ch))
magic2.c:      if (obj->plr_owner != NULL)
magic2.c:	if (str_cmp (ch->name, obj->plr_owner) && !IS_IMMORTAL(ch))
magic2.c:      if (obj->item_type == ITEM_QUIVER && has_quiver (ch))
magic2.c:		//    NULL, obj->name, TO_CHAR);
magic2.c:      if (obj->item_type == ITEM_MONEY)
magic2.c:	  ch->silver += obj->value[0];
magic2.c:	  ch->gold += obj->value[1];
magic2.c:	      if (members > 1 && (obj->value[0] > 1 || obj->value[1]))
magic2.c:		  sprintf (buffer, "%d %d", obj->value[0], obj->value[1]);
magic2.c:	  // if (obj != NULL && obj->pIndexData->vnum == OBJ_VNUM_CORPSE_PC)
magic2.c:	  obj_next = obj->next_content;
magic2.c:	  if (!IS_SET(obj->wear_flags,ITEM_TAKE))
magic2.c:	  if (IS_SET(obj->extra_flags[1],ITEM_WIZI) && !IS_IMMORTAL(ch))
magic2.c:	  if (!obj->in_room)
magic2.c:	  for (gch = obj->in_room->people; gch != NULL; gch = gch->next_in_room)
magic2.c:	  if ((!obj->in_obj || obj->in_obj->carried_by != ch)
magic2.c:	  if (IS_SET(obj->extra_flags[0],ITEM_NOMOB) && IS_NPC(ch))
magic2.c:	  if (obj->plr_owner != NULL)
magic2.c:	    if (str_cmp (ch->name, obj->plr_owner) && !IS_IMMORTAL(ch))
magic2.c:	  if (obj->item_type == ITEM_QUIVER && has_quiver (ch))
magic2.c:		    //    NULL, obj->name, TO_CHAR);
magic2.c:	  if (obj->item_type == ITEM_MONEY)
magic2.c:	      ch->silver += obj->value[0];
magic2.c:	      ch->gold += obj->value[1];
magic2.c:		  if (members > 1 && (obj->value[0] > 1 || obj->value[1]))
magic2.c:		      sprintf (buffer, "%d %d", obj->value[0], obj->value[1]);
magic2.c:	      // if (obj != NULL && obj->pIndexData->vnum == OBJ_VNUM_CORPSE_PC)
magic2.c:  log_string(obj->name);
magic2.c:  log_string(obj->in_room->name);
magic2.c:	    obj_next = obj->next_content;*/
magic2.c:              if (!IS_SET(obj->wear_flags,ITEM_TAKE))
magic2.c:	      if (IS_SET(obj->extra_flags[1],ITEM_WIZI) && !IS_IMMORTAL(ch))
magic2.c:              for (gch = obj->in_room->people; gch != NULL; gch = gch->next_in_room)
magic2.c:              if ((!obj->in_obj || obj->in_obj->carried_by != ch)
magic2.c:              if (IS_SET(obj->extra_flags[0],ITEM_NOMOB) && IS_NPC(ch))
magic2.c:              if (obj->plr_owner != NULL)
magic2.c:                if (str_cmp (ch->name, obj->plr_owner) && !IS_IMMORTAL(ch))
magic2.c:              if (obj->item_type == ITEM_QUIVER && has_quiver (ch))
magic2.c:                        //    NULL, obj->name, TO_CHAR);
magic2.c:              if (obj->item_type == ITEM_MONEY)
magic2.c:                  ch->silver += obj->value[0];
magic2.c:                  ch->gold += obj->value[1];
magic2.c:                      if (members > 1 && (obj->value[0] > 1 || obj->value[1]))
magic2.c:                          sprintf (buffer, "%d %d", obj->value[0], obj->value[1]);
magic2.c:		  // if (obj != NULL && obj->pIndexData->vnum == OBJ_VNUM_CORPSE_PC)
magic2.c:  if (obj->item_type == ITEM_BINDER)
magic2.c:  mob->short_descr = str_dup(obj->short_descr);
magic2.c:  sprintf(buf,mob->long_descr,obj->short_descr);
magic2.c:  switch (obj->item_type)
magic2.c:      if (IS_SET(obj->wear_flags,ITEM_WEAR_SHIELD))
magic2.c:      if (obj->pIndexData->vnum != OBJ_VNUM_RUNE_CONV)
magic2.c:      //      sprintf(buf,mob->long_descr,obj->short_descr);
magic2.c:  mob->name = str_dup(obj->name);
magic2.c:  mob->short_descr = str_dup(obj->short_descr);
magic2.c:  sprintf(buf,mob->long_descr,obj->short_descr);
magic2.c:  if (obj->contains)
magic2.c:      for (obj2 = obj->contains; obj2; obj2 = obj2_next)
magic.c:	if (obj->item_type != ITEM_DRINK_CON)
magic.c:	if (obj->value[2] != LIQ_WATER && obj->value[1] != 0)
magic.c:		obj->value[0] - obj->value[1]);
magic.c:		obj->value[2] = LIQ_WATER;
magic.c:		obj->value[1] += water;
magic.c:		if (!is_name ("water", obj->name))
magic.c:			sprintf (buf, "%s water", obj->name);
magic.c:			free_string (obj->name);
magic.c:			obj->name = str_dup (buf);
magic.c:			paf = affect_find (obj->affected, skill_lookup ("bless"));
magic.c:			if (!saves_dispel (level, paf != NULL ? paf->level : obj->level, 0))
magic.c:				REMOVE_BIT (obj->extra_flags[0], ITEM_BLESS);
magic.c:		SET_BIT (obj->extra_flags[0], ITEM_NODROP);
magic.c:	if (obj->item_type == ITEM_DRINK_CON || obj->item_type == ITEM_FOOD)
magic.c:		if (obj->value[3] != 0)
magic.c:	if (obj->item_type != ITEM_ARMOR)
magic.c:	if (obj->wear_loc != -1)
magic.c:	if (!obj->enchanted)
magic.c:		for (paf = obj->pIndexData->affected; paf != NULL; paf = paf->next)
magic.c:		for (paf = obj->affected; paf != NULL; paf = paf->next)
magic.c:			obj->enchanted = TRUE;
magic.c:			for (paf = obj->affected; paf != NULL; paf = paf_next)
magic.c:					obj->value[4] = obj->value[4] & !vector_to_remove;
magic.c:			obj->affected = NULL;
magic.c:				obj->extra_flags[i] = 0;
magic.c:		if (!obj->enchanted)
magic.c:			obj->enchanted = TRUE;
magic.c:			for (paf = obj->pIndexData->affected; paf != NULL; paf = paf->next)
magic.c:				af_new->next = obj->affected;
magic.c:				obj->affected = af_new;
magic.c:			SET_BIT (obj->extra_flags[0], ITEM_MAGIC);
magic.c:			SET_BIT (obj->extra_flags[0], ITEM_MAGIC);
magic.c:			SET_BIT (obj->extra_flags[0], ITEM_GLOW);
magic.c:		if (obj->level < LEVEL_HERO)
magic.c:			obj->level = UMIN (LEVEL_HERO - 1, obj->level + 1);
magic.c:			for (paf = obj->affected; paf != NULL; paf = paf->next)
magic.c:			paf->next = obj->affected;
magic.c:			obj->affected = paf;
magic.c:	if (obj->item_type != ITEM_WEAPON)
magic.c:	if (obj->wear_loc != -1)
magic.c:	if (!obj->enchanted)
magic.c:		for (paf = obj->pIndexData->affected; paf != NULL; paf = paf->next)
magic.c:		for (paf = obj->affected; paf != NULL; paf = paf->next)
magic.c:			obj->enchanted = TRUE;
magic.c:			for (paf = obj->affected; paf != NULL; paf = paf_next)
magic.c:						if (obj->value[4] & WEAPON_SHARP)
magic.c:							obj->value[4] -= WEAPON_SHARP;
magic.c:						if (obj->value[4] & WEAPON_POISON)
magic.c:							obj->value[4] -= WEAPON_POISON;
magic.c:						if (obj->value[4] & WEAPON_VAMPIRIC)
magic.c:							obj->value[4] -= WEAPON_VAMPIRIC;
magic.c:			obj->affected = NULL;
magic.c:				obj->extra_flags[i] = 0;
magic.c:		if (!obj->enchanted)
magic.c:			obj->enchanted = TRUE;
magic.c:			for (paf = obj->pIndexData->affected; paf != NULL; paf = paf->next)
magic.c:				af_new->next = obj->affected;
magic.c:				obj->affected = af_new;
magic.c:			SET_BIT (obj->extra_flags[0], ITEM_MAGIC);
magic.c:			SET_BIT (obj->extra_flags[0], ITEM_MAGIC);
magic.c:			SET_BIT (obj->extra_flags[0], ITEM_GLOW);
magic.c:		if (obj->level < LEVEL_HERO - 1)
magic.c:			obj->level = UMIN (LEVEL_HERO - 1, obj->level + 1);
magic.c:			for (paf = obj->affected; paf != NULL; paf = paf->next)
magic.c:						SET_BIT (obj->extra_flags[0], ITEM_HUM);
magic.c:			paf->next = obj->affected;
magic.c:			obj->affected = paf;
magic.c:			for (paf = obj->affected; paf != NULL; paf = paf->next)
magic.c:						SET_BIT (obj->extra_flags[0], ITEM_HUM);
magic.c:			paf->next = obj->affected;
magic.c:			obj->affected = paf;
magic.c:		obj->name, item_type_name (obj),
magic.c:		extra_bit_name_new (obj->extra_flags,FALSE), obj->weight / 10,
magic.c:		obj->cost, obj->level);
magic.c:	if (obj->wear_flags > ITEM_TAKE && obj->item_type != ITEM_LIGHT)
magic.c:		sprintf (buf, "worn: %s\n\r",wear_bit_name (obj->wear_flags - ITEM_TAKE));
magic.c:	crflag_string (pcrace_flags, obj->race_flags),
magic.c:	crflag_string (Class_flags, obj->Class_flags),
magic.c:	crflag_string (clan_flags, obj->clan_flags));
magic.c:	sprintf (buf, "   Used by - Races: %s", crflag_string (pcrace_flags, obj->race_flags));
magic.c:	sprintf (buf, " Classes: %s",crflag_string (Class_flags, obj->Class_flags));
magic.c:	sprintf (buf, " Clans: %s\n\r",crflag_string (clan_flags, obj->clan_flags));
magic.c:	sprintf (buf, "Condition : %s\n\r", condition_noun (obj->condition));
magic.c:	if (obj->plr_owner != NULL)
magic.c:		sprintf (buf, "Owner : %s\n\r", capitalize(obj->plr_owner));
magic.c:	switch (obj->item_type)
magic.c:		if (obj->value[0] > 0 && obj->value[0] < MAX_SKILL)
magic.c:			sprintf (buf, "Level %d spell of: '%s'\n\r", obj->level,
magic.c:				skill_table[obj->value[0]].name);
magic.c:		sprintf (buf, "Level %d spells of:", obj->value[0]);
magic.c:		if (obj->value[1] >= 0 && obj->value[1] < MAX_SKILL)
magic.c:			send_to_char (skill_table[obj->value[1]].name, ch);
magic.c:		if (obj->value[2] >= 0 && obj->value[2] < MAX_SKILL)
magic.c:			send_to_char (skill_table[obj->value[2]].name, ch);
magic.c:		if (obj->value[3] >= 0 && obj->value[3] < MAX_SKILL)
magic.c:			send_to_char (skill_table[obj->value[3]].name, ch);
magic.c:		if (obj->value[4] >= 0 && obj->value[4] < MAX_SKILL)
magic.c:			send_to_char (skill_table[obj->value[4]].name, ch);
magic.c:		sprintf (buf, "Has %d charges of level %d", obj->value[2],
magic.c:			obj->value[0]);
magic.c:		if (obj->value[3] >= 0 && obj->value[3] < MAX_SKILL)
magic.c:			send_to_char (skill_table[obj->value[3]].name, ch);
magic.c:		if (obj->value[6] >= 1 && obj->value[6] < MAX_SKILL)
magic.c:			sprintf (buf, "Has a charge of level %d", obj->value[5]);
magic.c:			send_to_char (skill_table[obj->value[6]].name, ch);
magic.c:		if (obj->value[2] == -1)
magic.c:			liq_table[obj->value[2]].liq_color,
magic.c:			liq_table[obj->value[2]].liq_name);
magic.c:			obj->value[0], obj->value[3], cont_bit_name (obj->value[1]));
magic.c:		if (obj->value[4] != 100)
magic.c:			sprintf (buf, "Weight multiplier: %d%%\n\r", obj->value[4]);
magic.c:		sprintf (buf, "Capacity: %d\n\r", obj->value[0]);
magic.c:		sprintf (buf, "HP Healing Bonus: %d",obj->value[3]-100);
magic.c:		sprintf (buf, "Mana Healing Bonus: %d",obj->value[4]-100);
magic.c:		switch (obj->value[0])
magic.c:		sprintf (buf, "Damage is %dd%d (average %d).\n\r", obj->value[1],
magic.c:			obj->value[2], (1 + obj->value[2]) * obj->value[1] / 2);
magic.c:		if (obj->value[4])
magic.c:				weapon_bit_name (obj->value[4]));
magic.c:		if (obj->value[0] == WEAPON_DICE)
magic.c:			sprintf (buf, "`jWeapon spell:`` %s\n\r",skill_table[obj->value[5]].name);
magic.c:			obj->value[0], obj->value[1], obj->value[2], obj->value[3]);
magic.c:	if (!obj->enchanted)
magic.c:		for (paf = obj->pIndexData->affected; paf != NULL; paf = paf->next)
magic.c:		for (paf = obj->affected; paf != NULL; paf = paf->next)
magic.c:	for (obj = object_list; obj != NULL; obj = obj->next)
magic.c:			|| !is_name_no_abbrev (target_name, obj->name)
magic.c:			|| obj->item_type == ITEM_CARD
magic.c:			|| number_percent () > 2 * level || ch->level < obj->level-10)
magic.c:		for (in_obj = obj; in_obj->in_obj != NULL; in_obj = in_obj->in_obj);
magic.c:		if (in_obj->carried_by != NULL && !IS_IMMORTAL (ch)
magic.c:			&& IS_IMMORTAL (in_obj->carried_by) && !IS_NPC (in_obj->carried_by))
magic.c:		if (!IS_IMMORTAL (ch) && in_obj->item_type == ITEM_PLAYER_DONATION)
magic.c:		if (!IS_IMMORTAL (ch) && in_obj->item_type == ITEM_CLAN_DONATION)
magic.c:		if (in_obj->carried_by != NULL && can_see (ch, in_obj->carried_by))
magic.c:				PERS (in_obj->carried_by, ch));
magic.c:			if (IS_IMMORTAL (ch) && in_obj->in_room != NULL)
magic.c:				in_obj->in_room->name, in_obj->in_room->vnum);
magic.c:				in_obj->in_room ==
magic.c:				NULL ? "somewhere" : in_obj->in_room->name);
magic.c:		if (obj->item_type == ITEM_FOOD || obj->item_type == ITEM_DRINK_CON)
magic.c:			obj->value[3] = 1;
magic.c:		if (obj->item_type == ITEM_WEAPON)
magic.c:	if (obj->item_type != ITEM_WAND && obj->item_type != ITEM_STAFF)
magic.c:	if (obj->value[0] > ch->level)
magic.c:	if (obj->value[1] == 0)
magic.c:	chance -= obj->value[3];	/* harder to do high-level spells */
magic.c:	chance -= (obj->value[1] - obj->value[2]) * (obj->value[1] - obj->value[2]);
magic.c:		obj->value[2] = UMAX (obj->value[1], obj->value[2]);
magic.c:		obj->value[1] = 0;
magic.c:		chargemax = obj->value[1] - obj->value[2];
magic.c:		obj->value[2] += chargeback;
magic.c:		obj->value[1] = 0;
magic.c:		if (obj->value[1] > 1)
magic.c:			obj->value[1]--;
magic.c:	for (obj = ch->carrying; obj != NULL; obj = obj->next_content)
magic.c:			if (is_name (vial_name, obj->name))
magic.c:			if (obj->item_type != ITEM_VIAL)
magic.c:			if (obj->value[0] != 0)
magic.c:					fcapitalize (obj->pIndexData->short_descr));
magic.c:				sprintf (tcbuf, "You brew %s of %s.\n\r", obj->short_descr,
magic.c:				sprintf (tcbuf, "$n brews %s of %s.", obj->short_descr,
magic.c:						obj->value[0] = -1;
magic.c:						obj->value[0] = sn;
magic.c:					obj->value[0] = sn;
magic.c:				obj->level = level;
magic.c:				sprintf (tcbuf, "%s of %s", obj->short_descr, skill_table[sn].name);
magic.c:				free_string (obj->short_descr);
magic.c:				obj->short_descr = str_dup (tcbuf);
magic.c:				sprintf (tcbuf, "%s %s",obj->name, skill_table[sn].name);
magic.c:				free_string (obj->name);
magic.c:				obj->name = str_dup(tcbuf);
magic.c:					obj->short_descr, skill_table[sn].name);
magic.c:					obj->short_descr, skill_table[sn].name);
magic.c:	for (obj = ch->carrying; obj != NULL; obj = obj->next_content)
magic.c:			if (is_name (parchment_name, obj->name))
magic.c:			if (obj->item_type == ITEM_SCROLL)
magic.c:			if (obj->item_type != ITEM_PARCHMENT)
magic.c:				if (obj->value[1] <= 0)
magic.c:					obj->value[1] = sn;
magic.c:					obj->value[2] = -1;
magic.c:				else if ((obj->value[2] <= 0))
magic.c:					if (  ((skill_table[obj->value[1]].type == SKILL_CAST) && ( (skill_table[sn].type == SKILL_PRAY)||(skill_table[sn].type == SKILL_CHANT)))
magic.c:						||((skill_table[obj->value[1]].type == SKILL_CHANT) && ( (skill_table[sn].type == SKILL_PRAY)||(skill_table[sn].type == SKILL_CAST)))
magic.c:						||((skill_table[obj->value[1]].type == SKILL_PRAY) && ( (skill_table[sn].type == SKILL_CAST)||(skill_table[sn].type == SKILL_CHANT))) ) 
magic.c:					if ( (true_level_for_skill(ch,obj->value[1]) + true_level_for_skill (ch, sn) ) > 90)
magic.c:						//			sprintf(tcbuf,"level -> %d, true level -> %d",level_for_skill(ch,obj->value[1]), true_level_for_skill (ch, sn));
magic.c:					obj->value[2] = sn;
magic.c:					obj->value[3] = -1;
magic.c:					skill_table[sn].name, obj->pIndexData->short_descr);
magic.c:					obj->pIndexData->short_descr);
magic.c:				obj->value[0] = ch->level;
magic.c:					sprintf (tcbuf, "%s of %s", obj->short_descr, skill_table[sn].name);
magic.c:					sprintf (tcbuf, "%s and %s", obj->short_descr, skill_table[sn].name);
magic.c:				obj->value[3] = -1;
magic.c:				obj->value[4] = -1;
magic.c:				obj->level = ch->level;
magic.c:				free_string (obj->short_descr);
magic.c:				obj->short_descr = str_dup (tcbuf);
magic.c:				sprintf (tcbuf, "%s %s", obj->name, skill_table[sn].name);
magic.c:				free_string (obj->name);
magic.c:				obj->name = str_dup(tcbuf);
magic.c:					skill_table[sn].name, obj->pIndexData->short_descr);
magic.c:					skill_table[sn].name, obj->pIndexData->short_descr);
maps.c:	      free_string (obj->short_descr);
maps.c:	      obj->short_descr = str_dup (lbuf);
maps.c:	  ed->next = obj->extra_descr;
maps.c:	  obj->extra_descr = ed;
mem.c:  for (ed = old_obj->extra_descr; ed != NULL; ed = ed->next)
mem.c:  for (af = old_obj->affected; af != NULL; af = af->next)
mem.c:  pObj->name = str_dup (old_obj->name);
mem.c:  pObj->short_descr = str_dup (old_obj->short_descr);
mem.c:  pObj->description = str_dup (old_obj->description);
mem.c:  pObj->material = str_dup (old_obj->material);
mem.c:  pObj->item_type = old_obj->item_type;
mem.c:    pObj->extra_flags[value] = old_obj->extra_flags[value];
mem.c:  pObj->wear_flags = old_obj->wear_flags;
mem.c:  pObj->Class_flags = old_obj->Class_flags;
mem.c:  pObj->race_flags = old_obj->race_flags;
mem.c:  pObj->clan_flags = old_obj->clan_flags;
mem.c:  pObj->level = old_obj->level;
mem.c://  pObj->condition = old_obj->condition;
mem.c:  pObj->weight = old_obj->weight;
mem.c:  pObj->rarity = old_obj->rarity;
mem.c:  pObj->timer = old_obj->timer;
mem.c:  pObj->cost = old_obj->cost;
mem.c:    pObj->value[value] = old_obj->value[value];
mem.c:  pObj->string1 = str_dup (old_obj->string1);
mem.c:  pObj->string2 = str_dup (old_obj->string2);
mem.c:  pObj->string3 = str_dup (old_obj->string3);
mem.c:  pObj->string4 = str_dup (old_obj->string4);
mem.c:  if (old_obj->plr_owner)
mem.c:    pObj->plr_owner = str_dup (old_obj->plr_owner);
mem.c:    pObj->obj_trig_vnum[value] = old_obj->obj_trig_vnum[value];
mob_scripts.c:    obj->cost = val;
mob_scripts.c:    obj->wear_flags = val;
mob_scripts.c:    obj->wear_loc = val;
mob_scripts.c:    obj->weight = val;
mob_scripts.c:    obj->item_type = val;
mob_scripts.c:    obj->level = val;
mob_scripts.c:    obj->condition = val;
mob_scripts.c:      free_string (obj->short_descr);
mob_scripts.c:      obj->short_descr = str_dup (arg2);
mob_scripts.c:      free_string (obj->description);
mob_scripts.c:      obj->description = str_dup (arg2);
mob_scripts.c:      free_string (obj->material);
mob_scripts.c:      obj->material = str_dup (arg2);
mob_scripts.c:      free_string (obj->name);
mob_scripts.c:      obj->name = str_dup (arg2);
mob_scripts.c:    obj->timer = val;
mob_scripts.c:    obj->extra_flags[0] = val;
mob_scripts.c:    obj->value[URANGE (0, atoi (arg3), 4)] = val;
mob_scripts.c:  for (obj = victim->carrying; obj; obj = obj->next_content)
mob_scripts.c:    if (obj->pIndexData->vnum == ovnum)
mob_scripts.c:    sprintf (buf, "%d", obj->cost);
mob_scripts.c:    sprintf (buf, "%d", obj->pIndexData->vnum);
mob_scripts.c:    sprintf (buf, "%s", obj->short_descr);
mob_scripts.c:    sprintf (buf, "%s", obj->description);
mob_scripts.c:    sprintf (buf, "%s", obj->material);
mob_scripts.c:    sprintf (buf, "%d", obj->in_room != NULL ? obj->in_room->vnum : 0);
mob_scripts.c:	     obj->in_obj != NULL ? STR (obj->in_obj, name) : "none");
mob_scripts.c:	     obj->carried_by != NULL ? obj->carried_by->name !=
mob_scripts.c:	     NULL ? obj->carried_by->name : obj->carried_by->
mob_scripts.c:    sprintf (buf, "%ld", obj->wear_flags);
mob_scripts.c:    sprintf (buf, "%ld", obj->wear_loc);
mob_scripts.c:    sprintf (buf, "%d", obj->weight);
mob_scripts.c:    sprintf (buf, "%d", obj->item_type);
mob_scripts.c:    sprintf (buf, "%d", obj->level);
mob_scripts.c:    sprintf (buf, "%d", obj->timer);
mob_scripts.c:    sprintf (buf, "%d", obj->condition);
mob_scripts.c:    sprintf (buf, "%ld", obj->extra_flags[0]);
mob_scripts.c:    sprintf (buf, "%d", obj->value[URANGE (0, atoi (arg3), 4)]);
music.c:  for (obj = object_list; obj != NULL; obj = obj->next)
music.c:      if (obj->item_type != ITEM_JUKEBOX || obj->value[1] < 0)
music.c:      if (obj->value[1] >= MAX_SONGS)
music.c:	  obj->value[1] = -1;
music.c:      if (obj->value[0] < 0)
music.c:		   song_table[obj->value[1]].group,
music.c:		   song_table[obj->value[1]].name);
music.c:	  if (obj->in_room->people != NULL)
music.c:	    act (buf, obj->in_room->people, obj, NULL, TO_ALL);
music.c:	  obj->value[0] = 0;
music.c:	  if (obj->value[0] >= MAX_LINES
music.c:	      || obj->value[0] >= song_table[obj->value[1]].lines)
music.c:	      obj->value[0] = -1;
music.c:	      obj->value[1] = obj->value[2];
music.c:	      obj->value[2] = obj->value[3];
music.c:	      obj->value[3] = obj->value[4];
music.c:	      obj->value[4] = -1;
music.c:	  line = song_table[obj->value[1]].lyrics[obj->value[0]];
music.c:	  obj->value[0]++;
music.c:      if (obj->in_room->people != NULL)
music.c:	act (buf, obj->in_room->people, obj, NULL, TO_ALL);
necro.c:// obj->value[5] will store the amount of uses possible for each -gram
necro.c:// obj->value[6] will store the total number of reinforcements
necro.c:      if (obj && str_cmp(obj->plr_owner,ch->name))
necro.c:	  obj->timer = 2;
necro.c:	  obj->value[5] = 1;
necro.c:	  obj->plr_owner = str_dup(ch->name);
necro.c:	  obj->timer += 2;
necro.c:	  obj->value[5]++;
necro.c:      if (obj && str_cmp(obj->plr_owner,ch->name))
necro.c:	  obj->timer = 5;
necro.c:	  obj->value[5] = 1;
necro.c:	  obj->value[6] = 0;
necro.c:	  obj->plr_owner = str_dup(ch->name);
necro.c:      else if (obj->value[6] < 2)
necro.c:	  obj->value[5]++;
necro.c:	  obj->value[6]++;
necro.c:	  obj->timer += 5;
necro.c:      if (obj && str_cmp(obj->plr_owner,ch->name))
necro.c:	  obj->timer = 7;
necro.c:	  obj->value[5] = 1;
necro.c:	  obj->value[6] = 0;
necro.c:	  obj->plr_owner = str_dup(ch->name);
necro.c:      else if (obj->value[6] < 1)
necro.c:	  obj->value[5]++;
necro.c:	  obj->value[6]++;
necro.c:	  obj->timer += 7;
necro.c:  switch (obj->pIndexData->vnum)
necro.c:  if (obj->timer == 0)
necro.c:    obj->timer = 0;
necro.c:    obj->value[5] = -1;
necro.c:  if (obj->item_type != ITEM_CORPSE_NPC)
necro.c:  if (obj->carried_by)
necro.c:      for (prev = obj->contains; prev != NULL; prev = prev_next)
necro.c:	  obj_to_room(prev,obj->carried_by->in_room);
necro.c:	  sprintf (buf, "$p falls from %s.", obj->short_descr);
necro.c:	      if (obj->pIndexData->vnum <= 5 && obj->pIndexData->vnum >= 1)
necro.c:		      tobj_next = tobj->next_content;
necro.c:		      switch (tobj->pIndexData->vnum)
necro.c:			  silver += tobj->value[0];
necro.c:			  gold += tobj->value[1];
necro.c:			  silver += tobj->value[0];
necro.c:			  gold += tobj->value[1];
necro.c:      for (prev = obj->contains; prev != NULL; prev = prev_next)
necro.c:	  obj_to_room(prev,obj->in_room);
necro.c:	  sprintf (buf, "$p falls from %s.", obj->short_descr);
necro.c:	      if (obj->pIndexData->vnum <= 5 && obj->pIndexData->vnum >= 1)
necro.c:		      tobj_next = tobj->next_content;
necro.c:		      switch (tobj->pIndexData->vnum)
necro.c:			  silver += tobj->value[0];
necro.c:			  gold += tobj->value[1];
necro.c:			  silver += tobj->value[0];
necro.c:			  gold += tobj->value[1];
necro.c:	      if (obj->pIndexData->vnum != OBJ_VNUM_RIB_BONE && obj->pIndexData->vnum != OBJ_VNUM_THIGH_BONE)
necro.c:		obj->timer = number_range (4, 7);
necro.c:	        sprintf (buf, obj->short_descr, name);
necro.c:	        free_string (obj->short_descr);
necro.c:	        obj->short_descr = str_dup (buf);
necro.c:	        sprintf (buf, obj->description, name);
necro.c:	        free_string (obj->description);
necro.c:	        obj->description = str_dup (buf);
necro.c:	      if (obj->item_type == ITEM_FOOD)
necro.c:		    obj->value[3] = 1;
necro.c:		    obj->item_type = ITEM_TRASH;
necro.c:	        obj->timer = 180;
necro.c:          obj_next = obj->next_content;
necro.c:      obj_next = obj->next_content;
necro.c:      if (IS_CLASS(ch,PC_CLASS_REAVER) && (obj->wear_loc == WEAR_WIELD_L || obj->wear_loc == WEAR_WIELD_R))
necro.c:      if (obj->wear_loc != WEAR_NONE)
obj_trig.c:	if(obj->objtrig[i] && IS_SET(obj->objtrig[i]->pIndexData->trig_flags, trig_type))
obj_trig.c:  	  if (should_be_tripped(ch,trig_type,obj->objtrig[i]->pIndexData,special,arg,victim))
obj_trig.c:	    activate_trigger(obj->objtrig[i], obj, ch, victim);
obj_trig.c:  for(obj = ch->in_room->contents; obj != NULL; obj = obj->next_content)
obj_trig.c:	  if(obj->objtrig[i] 
obj_trig.c:	     && IS_SET(obj->objtrig[i]->pIndexData->trig_flags, trig_type)
obj_trig.c:	     && IS_SET(obj->objtrig[i]->pIndexData->extra_flags, OT_EXTRA_WHEN_ON_GROUND))
obj_trig.c:	    if (should_be_tripped(ch,trig_type,obj->objtrig[i]->pIndexData,special,arg,victim))
obj_trig.c:	      activate_trigger(obj->objtrig[i], obj, ch, victim);
obj_trig.c:      for (obj = tch->carrying; obj != NULL; obj = obj->next_content)
obj_trig.c:	      if(obj->objtrig[i] && IS_SET(obj->objtrig[i]->pIndexData->trig_flags, trig_type))
obj_trig.c:		//  if(get_eq_char(tch, obj->wear_loc) == obj && obj->wear_loc != WEAR_NONE)
obj_trig.c:		if (obj->carried_by == tch && obj->wear_loc != WEAR_NONE)
obj_trig.c:		      if(IS_SET(obj->objtrig[i]->pIndexData->extra_flags, OT_EXTRA_WHEN_WORN))
obj_trig.c:		        if (should_be_tripped(ch,trig_type,obj->objtrig[i]->pIndexData,special,arg,victim))
obj_trig.c:			  activate_trigger(obj->objtrig[i], obj, ch, tch);
obj_trig.c:		      else if(IS_SET(obj->objtrig[i]->pIndexData->extra_flags, OT_EXTRA_WHEN_TRIGGERER_WORN)
obj_trig.c:		        if (should_be_tripped(ch,trig_type,obj->objtrig[i]->pIndexData,special,arg,victim))
obj_trig.c: 		          activate_trigger(obj->objtrig[i], obj, ch, victim);
obj_trig.c:		  else if(IS_SET(obj->objtrig[i]->pIndexData->extra_flags, OT_EXTRA_WHEN_CARRIED))
obj_trig.c: 		    if (should_be_tripped(ch,trig_type,obj->objtrig[i]->pIndexData,special,arg,victim))
obj_trig.c:		      activate_trigger(obj->objtrig[i], obj, ch, tch);
obj_trig.c:		  else if(IS_SET(obj->objtrig[i]->pIndexData->extra_flags, OT_EXTRA_WHEN_TRIGGERER_CARRIED)
obj_trig.c:		    if (should_be_tripped(ch,trig_type,obj->objtrig[i]->pIndexData,special,arg,victim))
obj_trig.c: 		      activate_trigger(obj->objtrig[i], obj, ch, victim);
obj_trig.c:	if ((obj->carried_by == NULL || obj->carried_by->in_room == NULL) && obj->in_room == NULL)
obj_trig.c:	variable_substitution_new(ch,ch->fighting,obj->carried_by,victim,raw_action);
obj_trig.c:	if(obj->carried_by == NULL) 
obj_trig.c:  	  if (obj->in_room)
obj_trig.c:	    char_to_room(ot->fakie, obj->in_room);
obj_trig.c:	  if (obj->carried_by->in_room)
obj_trig.c:	    char_to_room(ot->fakie, obj->carried_by->in_room);
obj_trig.c:	ot->fakie->short_descr = str_dup(obj->short_descr);
obj_trig.c:	ot->fakie->level = obj->level;
olc_act.c:  for (obj = pRoom->contents; obj; obj = obj->next_content)
olc_act.c:      one_argument (obj->name, buf);
olc_act.c:  dest_obj->vnum = dest_vnum;
olc_act.c:  dest_obj->area = pArea;
olc_act.c:  dest_obj->next = obj_index_hash[iHash];
olc_act.c:      pReset->arg3 = to_obj->pIndexData->vnum;
olc_act.c:             insert_obj_reset(pRoom, pReset, to_obj->pIndexData->vnum, 
olc_act.c:      newobj->cost = 0;
olc_act.c:	       capitalize (newobj->short_descr),
olc_act.c:	       newobj->pIndexData->vnum, to_obj->short_descr,
olc_act.c:	       to_obj->pIndexData->vnum);
olc_act.c:	    SET_BIT (newobj->extra_flags[0], ITEM_INVENTORY);
olc_act.c:  switch (obj->item_type)
olc_act.c:      sprintf (buf, "[v0] Hours message lasts:  [%d]\n\r", obj->value[0]);
olc_act.c:      if (obj->value[2] == -1 || obj->value[2] == 999)	/* ROM OLC */
olc_act.c:	sprintf (buf, "[v2] Light:  [%d]\n\r", obj->value[2]);
olc_act.c:	       "[v2] Charges Left:   [%d]\n\r[v3] ", obj->value[0],
olc_act.c:	       obj->value[1], obj->value[2]);
olc_act.c:      switch (skill_table[obj->value[3]].type)
olc_act.c:		obj->value[3] >=
olc_act.c:		0 ? skill_table[obj->value[3]].name : "none");
olc_act.c:      sprintf (buf, "[v0] Level:  [%d]\n\r[v1] ", obj->value[0]);
olc_act.c:      switch (skill_table[obj->value[1]].type)
olc_act.c:	      obj->value[1] != -1 ? skill_table[obj->value[1]].name : "none");
olc_act.c:      switch (skill_table[obj->value[2]].type)
olc_act.c:	      obj->value[2] != -1 ? skill_table[obj->value[2]].name : "none");
olc_act.c:      switch (skill_table[obj->value[3]].type)
olc_act.c:	      obj->value[3] != -1 ? skill_table[obj->value[3]].name : "none");
olc_act.c:      switch (skill_table[obj->value[4]].type)
olc_act.c:	      obj->value[4] != -1 ? skill_table[obj->value[4]].name : "none");
olc_act.c:	       "[v3] Ac exotic       [%d]\n\r", obj->value[0],
olc_act.c:	       obj->value[1], obj->value[2], obj->value[3]);
olc_act.c:      sprintf (buf, "[v0] Number of People: %d\n\r", obj->value[0]);
olc_act.c:      sprintf (buf, "[v1] Total Weight: %d\n\r", obj->value[1]);
olc_act.c:	       flag_string (furniture_type, obj->value[2]));
olc_act.c:      sprintf (buf, "[v3] Heal Bonus: %d\n\r", obj->value[3]);
olc_act.c:      sprintf (buf, "[v4] Mana Bonus: %d\n\r", obj->value[4]);
olc_act.c:      sprintf (buf, "[v0] Number of People: %d\n\r", obj->value[0]);
olc_act.c:      sprintf (buf, "[v1] Total Weight: %d\n\r", obj->value[1]);
olc_act.c:          flag_string (furniture_type, obj->value[2]));
olc_act.c:          flag_string (tsector_flags, obj->value[3]));
olc_act.c:	       flag_string (tsector_flags, obj->value[0]));
olc_act.c:	       "[v4] Action types:  [%s]\n\r", obj->value[1],
olc_act.c:	       obj->value[2], obj->value[3], flag_string (tact_flags,
olc_act.c:							  obj->value[4]));
olc_act.c:	       flag_string (container_flags, obj->value[5]), obj->value[6]);
olc_act.c:	       obj->value[0], obj->value[1], obj->value[2]);
olc_act.c:	       "[v2] Elevator goto:  [%d]\n\r", obj->value[0],
olc_act.c:	       obj->value[1], obj->value[2]);
olc_act.c:	       flag_string (button_flags, obj->value[3]));
olc_act.c:	       flag_string (instrument_flags, obj->value[0]));
olc_act.c:      sprintf (buf, "[v0] Key Saved:  %s\n\r", obj->value[0] ? "Yes" : "No");
olc_act.c:      sprintf (buf, "[v0] Max Items: %d\n\r", obj->value[0]);
olc_act.c:      sprintf (buf, "[v0] Capacity: %d\n\r", obj->value[0]);
olc_act.c:      sprintf (buf, "[v0] Capacity: %d\n\r", obj->value[0]);
olc_act.c:      sprintf (buf, "[v1] Baited: %d\n\r", obj->value[0]);
olc_act.c:      sprintf (buf, "[v0] Max Items: %d\n\r", obj->value[0]);
olc_act.c:      if (obj->value[1] == CLAN_BOGUS)
olc_act.c:		   get_clan_name (obj->value[1]));
olc_act.c:     	sprintf (buf, "[v0] Trap Type:       %s\n\r", flag_string (trap_type, obj->value[0]));
olc_act.c:	switch(obj->value[0])
olc_act.c:		switch (skill_table[obj->value[1]].type)
olc_act.c:        	strcat (buf, obj->value[1] != -1 ? skill_table[obj->value[1]].name : "none");
olc_act.c:		 sprintf (buf, "\n\r[v2] Spell Level:    [%d]\n\r", obj->value[2]);
olc_act.c:	     	sprintf (buf, "[v1] Number of dice:  [%d]\n\r", obj->value[1]);
olc_act.c:		sprintf (buf, "[v2] Type of dice:    [%d]\n\r", obj->value[2]);
olc_act.c:		sprintf	(buf, "[v3] Damage Mod:      [%d]\n\r", obj->value[3]);
olc_act.c:	sprintf (buf, "[v5] Trap Dex:        [%d]\n\r", obj->value[5]);
olc_act.c:	sprintf (buf, "[v6] Summon Mob Vnum: [%d]\n\r", obj->value[6]);
olc_act.c:	if (obj->value[0] >= MIN_PORTAL_TRAP && obj->value[0] <= MAX_PORTAL_TRAP)
olc_act.c:		if (obj->value[7] <= -1)
olc_act.c:			sprintf (buf, "[v7] Trap Exit Type:  [%s]\n\r", flag_string (pact_flags,obj->value[7]));
olc_act.c:     	sprintf (buf, "[v8] Damage Type:     %s\n\r", flag_string (weapon_flags, obj->value[8]));
olc_act.c:	if (obj->value[0] >= MIN_PORTAL_TRAP && obj->value[0] <= MAX_PORTAL_TRAP)
olc_act.c:		if(obj->value[9] <= -1)
olc_act.c:			sprintf (buf, "[v9] Trap Door Dir:   [%s]\n\r", flag_string (dir_flags,obj->value[9]));
olc_act.c:	       flag_string (weapon_Class, obj->value[0]));
olc_act.c:      sprintf (buf, "[v1] Number of dice: [%d]\n\r", obj->value[1]);
olc_act.c:      sprintf (buf, "[v2] Type of dice:   [%d]\n\r", obj->value[2]);
olc_act.c:	       flag_string (weapon_flags, obj->value[3]));
olc_act.c:	       flag_string (weapons_type, obj->value[4]));
olc_act.c:      if (obj->value[0] == WEAPON_DICE)
olc_act.c:	if (obj->value[5] > MAX_SKILL || skill_table[obj->value[5]].name == NULL
olc_act.c:			|| skill_table[obj->value[5]].type == SKILL_NORMAL ||
olc_act.c:			obj->value[5] < 0)
olc_act.c:  	  obj->value[5] = 0;
olc_act.c:        sprintf (buf, "[v5] Spell:          %s\n\r",skill_table[obj->value[5]].name);
olc_act.c:	       "[v4] Weight Multiplier: [%d]\n\r", obj->value[0],
olc_act.c:	       flag_string (container_flags, obj->value[1]),
olc_act.c:	       obj->value[2], obj->value[3], obj->value[4]);
olc_act.c:	       "[v4] Weight Multiplier: [%d]\n\r", obj->value[0],
olc_act.c:	       flag_string (container_flags, obj->value[1]),
olc_act.c:	       obj->value[3], obj->value[4]);
olc_act.c:	       "[v3] Poisoned:     %s\n\r", obj->value[0],
olc_act.c:	       obj->value[1], flag_string (liquid_flags, obj->value[2]),
olc_act.c:	       obj->value[3] != 0 ? "Yes" : "No");
olc_act.c:							 obj->value[2]),
olc_act.c:	       obj->value[3] != 0 ? "Yes" : "No");
olc_act.c:	       "[v1] ExitFlags: [%s]\n\r", obj->value[0],
olc_act.c:	       flag_string (exit_flags, obj->value[1]));
olc_act.c:						     obj->value[2]),
olc_act.c:	       obj->value[3]);
olc_act.c:	       flag_string (pact_flags, obj->value[4]));
olc_act.c:	       "[v1] VnumTo: [%d]\n\r", obj->value[0], obj->value[1]);
olc_act.c:	       "[v3] Poisoned:   %s\n\r", obj->value[0], obj->value[1],
olc_act.c:	       obj->value[2], obj->value[3] != 0 ? "Yes" : "No");
olc_act.c:      sprintf (buf, "[v0] Silver:   [%d]\n\r", obj->value[0]);
olc_act.c:      sprintf (buf, "[v1] Gold:     [%d]\n\r", obj->value[1]);
olc_act.c:      if (obj->value[0] < 0 || obj->value[0] >= MAX_TREES)
olc_act.c:        obj->value[0] = 0;
olc_act.c:      sprintf (buf, "[v0] Wood Type:  %s\n\r", tree_table[obj->value[0]].name);
olc_act.c:      sprintf (buf, "[v0] Card number:     [%d]\n\r",obj->value[0]);
olc_act.c:      sprintf (buf, "[v1] Card type:       %s\n\r", flag_string (card_Class, obj->value[1]));
olc_act.c:      sprintf (buf, "[v2] Number of dice:  [%d]\n\r", obj->value[2]);
olc_act.c:      sprintf (buf, "[v3] Type of dice:    [%d]\n\r", obj->value[3]);
olc_act.c:      sprintf (buf, "[v4] Bonus to dice:   [%d]\n\r",obj->value[4]);
olc_act.c:      sprintf (buf, "[v5] Level of spell:  [%d]\n\r[v6] ",obj->value[5]);
olc_act.c:      switch (skill_table[obj->value[6]].type)
olc_act.c:                obj->value[6] >=
olc_act.c:                0 ? skill_table[obj->value[6]].name : "none");
olc_act.c:      switch (obj->value[1])
olc_act.c:  	  sprintf (buf, "[v7] Hitpoints:       [%d]\n\r",obj->value[7]);
olc_act.c:	  sprintf (buf, "[v8] Offence:         [%d]\n\r",obj->value[8]);
olc_act.c: 	  sprintf (buf, "[v9] Defence:         [%d]\n\r",obj->value[9]);
olc_act.c:	  sprintf (buf, "[v10] Race:           %s\n\r",flag_string (card_race_type, obj->value[10]));
olc_act.c:	  sprintf (buf, "[v11] Element:        %s\n\r",flag_string (card_element_type, obj->value[11]));
olc_act.c:	  sprintf (buf, "[v12] Nemesis:        %s\n\r",flag_string (card_race_type, obj->value[12]));
olc_act.c:	  sprintf (buf, "[v7] Terrain type:                 %s\n\r", flag_string (card_terrain_type, obj->value[7]));
olc_act.c:	  sprintf (buf, "[v8] Off Bonus for Non-Elems mobs and damage: [%d]\n\r",obj->value[8]);
olc_act.c:	  sprintf (buf, "[v9] Def Bonus for Non-Elems mobs:            [%d]\n\r", obj->value[9]);
olc_act.c:	  sprintf (buf, "[v10] Off Bonus for Elems mobs and damage:    [%d]\n\r", obj->value[10]);
olc_act.c:	  sprintf (buf, "[v11] Def Bonus for Elems mobs:               [%d]\n\r", obj->value[11]);
olc_act.c:	  sprintf (buf, "[v12] Terrain Toggles:                        %s\n\r",flag_string (card_terrain_toggles, obj->value[12]));
olc_act.c:	  sprintf (buf, "[v7] Heal Amount:     [%d]\n\r",obj->value[7]);
olc_act.c:          sprintf (buf, "[v7] Damage Amount:   [%d]\n\r",obj->value[7]);
olc_act.c:	  sprintf (buf, "[v8] Element:         %s\n\r",flag_string (card_element_type, obj->value[8]));
olc_act.c:	  sprintf (buf, "[v7] Off Bonus:       [%d]\n\r",obj->value[7]);
olc_act.c:          sprintf (buf, "[v8] Def Bonus:       [%d]\n\r",obj->value[8]);
olc_act.c:  for (obj = object_list; obj != NULL; obj = obj->next)
olc_act.c:      if (obj->pIndexData == pObj)
olc_act.c:      if (obj->item_type != ITEM_CARD)
pray.c:      obj_next = obj->next_content;
pray.c:      if (obj->wear_loc == WEAR_NONE)
pray.c:      obj_next = obj->next_content;
pray.c:      if (obj->wear_loc == WEAR_NONE)
pray.c:  for (obj = object_list; obj != NULL; obj = obj->next)
pray.c:	  || !is_name_no_abbrev (pray_target_name, obj->name)
pray.c:	  || obj->item_type == ITEM_CARD
pray.c:	  || number_percent () > 2 * level || ch->level < obj->level-10)
pray.c:      for (in_obj = obj; in_obj->in_obj != NULL; in_obj = in_obj->in_obj);
pray.c:      if (in_obj->carried_by != NULL && !IS_IMMORTAL (ch)
pray.c:	  && IS_IMMORTAL (in_obj->carried_by) && !IS_NPC (in_obj->carried_by))
pray.c:      if (in_obj->carried_by != NULL && can_see (ch, in_obj->carried_by))
pray.c:		   PERS (in_obj->carried_by, ch));
pray.c:	  if (IS_IMMORTAL (ch) && in_obj->in_room != NULL)
pray.c:		     in_obj->in_room->name, in_obj->in_room->vnum);
pray.c:		     in_obj->in_room == NULL
pray.c:		     ? "somewhere" : in_obj->in_room->name);
pray.c:	  paf = affect_find (obj->affected, gsn_curse);
pray.c:	  if (!saves_dispel (level, paf != NULL ? paf->level : obj->level, 0))
pray.c:	      REMOVE_BIT (obj->extra_flags[0], ITEM_EVIL);
pray.c:	      && !saves_dispel (level + 2, obj->level, 0))
pray.c:	      REMOVE_BIT (obj->extra_flags[0], ITEM_NODROP);
pray.c:	      REMOVE_BIT (obj->extra_flags[0], ITEM_NOREMOVE);
pray.c:       obj = obj->next_content)
pray.c:	  if (!saves_dispel (level, obj->level, 0))
pray.c:	      REMOVE_BIT (obj->extra_flags[0], ITEM_NODROP);
pray.c:	      REMOVE_BIT (obj->extra_flags[0], ITEM_NOREMOVE);
pray.c:  free_string (pobj->description);
pray.c:  pobj->description = str_dup ("");
pray.c:  free_string (pobj->short_descr);
pray.c:  pobj->short_descr = str_dup ("a portal to haven");
pray.c:  free_string (pobj->name);
pray.c:  pobj->name = str_dup ("haven");
pray.c:  pobj->timer = 5;
pray.c:    pobj->timer = 1;
pray.c:    pobj->timer = 2;
pray.c:    pobj->timer = 3;
pray.c:    pobj->timer = 4;
pray.c:  pobj->value[0] = -1;
pray.c:  pobj->value[2] = GATE_SHOWEXIT;
pray.c:  pobj->value[3] = vnum;
pray.c:  pobj->value[4] = PACT_ENTER;
pray.c:  free_string (pobj->description);
pray.c:  pobj->description = str_dup ("");
pray.c:  free_string (pobj->short_descr);
pray.c:  pobj->short_descr = str_dup ("a portal from haven");
pray.c:  free_string (pobj->name);
pray.c:  pobj->name = str_dup ("haven");
pray.c:  pobj->value[0] = -1;
pray.c:  pobj->value[2] = GATE_SHOWEXIT;
pray.c:  pobj->value[3] = ch->in_room->vnum;
pray.c:  pobj->value[4] = PACT_EXIT;
quest.c:	  free_string(obj->plr_owner);
quest.c:	  obj->plr_owner = str_dup(ch->name);
quest.c:	  free_string(obj->short_descr);
quest.c:	  obj->short_descr = str_dup(buf);
quest.c:	  free_string(obj->name);
quest.c:	  obj->name = str_dup(buf);
quest.c:	  free_string(obj->description);
quest.c:	  obj->description = str_dup(buf);
quest.c:	      obj->extra_flags[0] |= ITEM_NOLOCATE | ITEM_NOPURGE | ITEM_NOSAVE | ITEM_NOIDENTIFY;
quest.c:	      obj->item_type = ITEM_TRASH;
quest.c:	  sprintf(buf,"%s, %s `Khas been stolen from King Athanmere's treasury.",ch->name, obj->short_descr);
quest.c:          sprintf(buf,"I'm sorry you were unable to complete the quest to return %s.\n\r",ch->pcdata->quest_obj->short_descr);
quest.c:	if (ch->pcdata->quest_obj->in_room == NULL)
quest.c: 	  if (ch->pcdata->quest_obj->carried_by && ch->pcdata->quest_obj->carried_by->in_room)
quest.c:	    if (ch->pcdata->quest_obj->carried_by == ch)
quest.c:			    ch->pcdata->quest_obj->short_descr, ch->pcdata->quest_obj->carried_by->in_room->name,
quest.c:	else if (ch->in_room && !str_cmp(ch->in_room->area->name,ch->pcdata->quest_obj->in_room->area->name))
quest.c:			  ch->pcdata->quest_obj->short_descr, ch->pcdata->quest_obj->in_room->name
quest.c:			ch->pcdata->quest_obj->short_descr,
quest.c:			ch->pcdata->quest_obj->in_room->area->name,ch->pcdata->quest_ticks);
quest.c:	  if (ch->pcdata->quest_obj->carried_by != ch)
quest.c:	      sprintf(buf,"%s You do not appear to have retrieved %s.",ch->name,ch->pcdata->quest_obj->short_descr);
quest.c:	      sprintf(buf,"Thank you for returning %s`K, %s!",ch->pcdata->quest_obj->short_descr,ch->name);
quest.c:			      mob->short_descr,ch->pcdata->quest_obj->short_descr);
quest.c:			      mob->short_descr,ch->pcdata->quest_obj->short_descr,ch->name);
recycle.c:  for (paf = obj->affected; paf != NULL; paf = paf_next)
recycle.c:  obj->affected = NULL;
recycle.c:  for (ed = obj->extra_descr; ed != NULL; ed = ed_next)
recycle.c:  obj->extra_descr = NULL;
recycle.c:  free_string (obj->name);
recycle.c:  free_string (obj->description);
recycle.c:  free_string (obj->short_descr);
recycle.c:  free_string (obj->owner);
recycle.c:  if (obj->plr_owner)
recycle.c:    free_string (obj->plr_owner);
recycle.c:    if (obj->objtrig[i])
recycle.c:      obj->objtrig[i]->obj_on = NULL;
recycle.c:      free_ot(obj->objtrig[i]);
recycle.c:      obj->objtrig[i] = NULL;
recycle.c:  obj->next = obj_free;
recycle.c:      obj_next = obj->next_content;
save.c:  sprintf (buf, "Vnum %d\n", obj->pIndexData->vnum);
save.c:  if (obj->enchanted)
save.c:  if (obj->name != obj->pIndexData->name)
save.c:      sprintf (buf, "Name %s~\n", obj->name);
save.c:  if (obj->owner != NULL && obj->owner[0] != '\0')
save.c:      sprintf (buf, "OwnR %s~\n", obj->owner);
save.c:  sprintf (buf, "ShD  %s~\n", obj->short_descr);
save.c:  sprintf (buf, "Desc %s~\n", obj->description);
save.c:    if (obj->extra_flags[i] != obj->pIndexData->extra_flags[i])
save.c:        sprintf (buf, "ExF %d %ld\n", i, obj->extra_flags[i]);
save.c:  if (obj->wear_flags != obj->pIndexData->wear_flags)
save.c:      sprintf (buf, "WeaF %ld\n", obj->wear_flags);
save.c:      sprintf (buf, " %d", obj->bs_capacity[i]);
save.c:      sprintf (buf, " %d", obj->bs_charges[i]);
save.c:      sprintf (buf, " %d", obj->bb_capacity[i]);
save.c:      sprintf (buf, " %d", obj->bb_charges[i]);
save.c:  if (obj->Class_flags != obj->pIndexData->Class_flags)
save.c:      sprintf (buf, "ClassF %ld\n", obj->Class_flags);
save.c:  if (obj->race_flags != obj->pIndexData->race_flags)
save.c:      sprintf (buf, "RaceF %ld\n", obj->race_flags);
save.c:  if (obj->clan_flags != obj->pIndexData->clan_flags)
save.c:      sprintf (buf, "ClanF %ld\n", obj->clan_flags);
save.c:  if (obj->bs_capacity[0] != 0)
save.c:      sprintf (buf, "Cardslot %d\n", obj->bs_capacity[0]);
save.c:  if (obj->item_type != obj->pIndexData->item_type)
save.c:      sprintf (buf, "Ityp %d\n", obj->item_type);
save.c:  if (obj->weight != obj->pIndexData->weight)
save.c:      sprintf (buf, "Wt   %d\n", obj->weight);
save.c:  if (obj->condition != obj->pIndexData->condition)
save.c:      sprintf (buf, "Cond %d\n", obj->condition);
save.c:  sprintf (buf, "WearL %ld\n", obj->wear_loc);
save.c:  if (obj->level != obj->pIndexData->level)
save.c:      sprintf (buf, "Lev  %d\n", obj->level);
save.c:  if (obj->timer != 0)
save.c:      sprintf (buf, "Time %d\n", obj->timer);
save.c:  sprintf (buf, "Cost %d\n", obj->cost);
save.c:  if (obj->value[0] != obj->pIndexData->value[0]
save.c:      || obj->value[1] != obj->pIndexData->value[1]
save.c:      || obj->value[2] != obj->pIndexData->value[2]
save.c:      || obj->value[3] != obj->pIndexData->value[3]
save.c:      || obj->value[4] != obj->pIndexData->value[4]
save.c:      || obj->value[5] != obj->pIndexData->value[5]
save.c:      || obj->value[6] != obj->pIndexData->value[6]
save.c:      || obj->value[7] != obj->pIndexData->value[7]
save.c:      || obj->value[8] != obj->pIndexData->value[8]
save.c:      || obj->value[9] != obj->pIndexData->value[9]
save.c:      || obj->value[10] != obj->pIndexData->value[10]
save.c:      || obj->value[11] != obj->pIndexData->value[11]
save.c:      || obj->value[12] != obj->pIndexData->value[12]
save.c:	       obj->value[0], obj->value[1], obj->value[2], obj->value[3],
save.c:	       obj->value[4], obj->value[5], obj->value[6], obj->value[7],
save.c:	       obj->value[8], obj->value[9], obj->value[10], obj->value[11], obj->value[12] );
save.c:  for (paf = obj->affected; paf != NULL; paf = paf->next)
save.c:      for (taf = obj->pIndexData->affected;taf != NULL;taf = taf->next)
save.c:  for (ed = obj->extra_descr; ed != NULL; ed = ed->next)
save.c:      obj->name = str_dup ("");
save.c:      obj->short_descr = str_dup ("");
save.c:      obj->description = str_dup ("");
save.c:      obj->extra_descr = NULL;
save.c:	      paf->next = obj->affected;
save.c:	      obj->affected = paf;
save.c:	      paf->next = obj->affected;
save.c:	      obj->affected = paf;
save.c:		  obj->bs_capacity[i] = fread_number (fp);
save.c:	      obj->bs_capacity[6]=0;
save.c:	          obj->bs_capacity[i] = fread_number (fp);
save.c:		  obj->bs_charges[i] = fread_number (fp);
save.c:	      obj->bs_charges[6] = 0;
save.c:	      obj->bs_charges[i] = fread_number (fp);
save.c:		  obj->bb_capacity[i] = fread_number (fp);
save.c:		  obj->bb_charges[i] = fread_number (fp);
save.c:	  KEY ("Cardslot", obj->bs_capacity[0], fread_number (fp));
save.c:	  KEY ("ClanFlags", obj->clan_flags, fread_flag (fp));
save.c:	  KEY ("ClanF", obj->clan_flags, fread_flag (fp));
save.c:	  KEY ("ClassFlags", obj->Class_flags, fread_flag (fp));
save.c:	  KEY ("ClassF", obj->Class_flags, fread_flag (fp));
save.c:	  KEY ("Cond", obj->condition, fread_number (fp));
save.c:	  KEY ("Cost", obj->cost, fread_number (fp));
save.c:	  KEY ("Description", obj->description, fread_string (fp));
save.c:	  KEY ("Desc", obj->description, fread_string (fp));
save.c:	      obj->enchanted = TRUE;
save.c:	  KEY ("ExtraFlags", obj->extra_flags[0], fread_number (fp));
save.c:	  KEY ("ExtF", obj->extra_flags[0], fread_number (fp));
save.c:		  obj->extra_flags[ai] = fread_number (fp);
save.c:	      cur = obj->extra_descr;
save.c:		  ed->next = obj->extra_descr;
save.c:		  obj->extra_descr = ed;
save.c:	      // if (!fNest || !fVnum || obj->pIndexData == NULL)
save.c:	      if (obj->condition == 0)
save.c:		obj->condition = 100;
save.c:	  KEY ("ItemType", obj->item_type, fread_number (fp));
save.c:	  KEY ("Ityp", obj->item_type, fread_number (fp));
save.c:	  KEY ("Level", obj->level, fread_number (fp));
save.c:	  KEY ("Lev", obj->level, fread_number (fp));
save.c:	  KEY ("Name", obj->name, fread_string (fp));
save.c:	  KEY ("OwnR", obj->owner, fread_string (fp));
save.c:	      if (obj->pIndexData != NULL)
save.c:	  KEY ("RaceFlags", obj->race_flags, fread_flag (fp));
save.c:	  KEY ("RaceF", obj->race_flags, fread_flag (fp));
save.c:	  KEY ("ShortDescr", obj->short_descr, fread_string (fp));
save.c:	  KEY ("ShD", obj->short_descr, fread_string (fp));
save.c:		  obj->value[iValue] = sn;
save.c:	  KEY ("Timer", obj->timer, fread_number (fp));
save.c:	  KEY ("Time", obj->timer, fread_number (fp));
save.c:	      obj->value[0] = fread_number (fp);
save.c:	      obj->value[1] = fread_number (fp);
save.c:	      obj->value[2] = fread_number (fp);
save.c:	      obj->value[3] = fread_number (fp);
save.c:	      if (obj->item_type == ITEM_WEAPON && obj->value[0] == 0)
save.c:		obj->value[0] = obj->pIndexData->value[0];
save.c:	      obj->value[0] = fread_number (fp);
save.c:	      obj->value[1] = fread_number (fp);
save.c:	      obj->value[2] = fread_number (fp);
save.c:	      obj->value[3] = fread_number (fp);
save.c:	      obj->value[4] = fread_number (fp);
save.c:	      obj->value[5] = fread_number (fp);
save.c:	      obj->value[6] = fread_number (fp);
save.c:		  obj->value[0] = fread_number (fp);
save.c:		  obj->value[1] = fread_number (fp);
save.c:		  obj->value[2] = fread_number (fp);
save.c:		  obj->value[3] = fread_number (fp);
save.c:		  obj->value[4] = fread_number (fp);
save.c:		  obj->value[5] = fread_number (fp);
save.c:		  obj->value[6] = fread_number (fp);
save.c:		  obj->value[7] = fread_number (fp);
save.c:		  obj->value[8] = fread_number (fp);
save.c:		  obj->value[9] = fread_number (fp);
save.c:		  obj->value[10] = fread_number (fp);
save.c://		  obj->value[11] = fread_number (fp);
save.c://		  obj->value[12] = fread_number (fp);
save.c:	      obj->value[0] = fread_number (fp);
save.c:	      obj->value[1] = fread_number (fp);
save.c:	      obj->value[2] = fread_number (fp);
save.c:	      obj->value[3] = fread_number (fp);
save.c:	      obj->value[4] = fread_number (fp);
save.c:	      obj->value[5] = fread_number (fp);
save.c:	      obj->value[6] = fread_number (fp);
save.c:	      obj->value[7] = fread_number (fp);
save.c:	      obj->value[8] = fread_number (fp);
save.c:	      obj->value[9] = fread_number (fp);
save.c:	      obj->value[10] = fread_number (fp);
save.c:	      obj->value[11] = fread_number (fp);
save.c:	      obj->value[12] = fread_number (fp);
save.c:	      if ((obj->pIndexData = get_obj_index (vnum)) == NULL)
save.c:	  KEY ("WearFlags", obj->wear_flags, fread_number (fp));
save.c:	  KEY ("WeaF", obj->wear_flags, fread_number (fp));
save.c:	  KEY ("WearLoc", obj->wear_loc, fread_number (fp));
save.c:          KEY ("WearL", obj->wear_loc, fread_number (fp));
save.c://	  KEY ("Wear", obj->wear_loc, fread_number (fp));
save.c:	  KEY ("Weight", obj->weight, fread_number (fp));
save.c:	  KEY ("Wt", obj->weight, fread_number (fp));
save.c:               obj->wear_loc = -1;
save.c:	 	      obj->wear_loc = wear_conversion_table[i].wear_flag;
save.c:  //if ((ch->level < obj->level - 20 && obj->item_type != ITEM_CONTAINER)
save.c:  //  || (obj->item_type == ITEM_KEY && !obj->value[0])
save.c:  //    || (obj->item_type == ITEM_MAP && !obj->value[0]))
save.c:  sprintf (buf, "Vnum %d\n", obj->pIndexData->vnum);
save.c:  if (obj->enchanted)
save.c:  if (obj->name != obj->pIndexData->name)
save.c:      sprintf (buf, "Name %s~\n", obj->name);
save.c:  if (obj->owner != NULL && obj->owner[0] != '\0')
save.c:      sprintf (buf, "OwnR %s~\n", obj->owner);
save.c:  if (obj->short_descr != obj->pIndexData->short_descr)
save.c:      sprintf (buf, "ShD  %s~\n", obj->short_descr);
save.c:  if (obj->description != obj->pIndexData->description)
save.c:      sprintf (buf, "Desc %s~\n", obj->description);
save.c:      if (obj->extra_flags[i] != obj->pIndexData->extra_flags[i])
save.c:         sprintf (buf, "ExF %d %ld\n", i, obj->extra_flags[i]);
save.c:  if (obj->wear_flags != obj->pIndexData->wear_flags)
save.c:      sprintf (buf, "WeaF %ld\n", obj->wear_flags);
save.c:  if (obj->Class_flags != obj->pIndexData->Class_flags)
save.c:      sprintf (buf, "ClassF %ld\n", obj->Class_flags);
save.c:  if (obj->race_flags != obj->pIndexData->race_flags)
save.c:      sprintf (buf, "RaceF %ld\n", obj->race_flags);
save.c:  if (obj->clan_flags != obj->pIndexData->clan_flags)
save.c:      sprintf (buf, "ClanF %ld\n", obj->clan_flags);
save.c:  if (obj->bs_capacity[0] != 0)
save.c:	  sprintf (buf, "Cardslot %d\n", obj->bs_capacity[0]);
save.c:  if (obj->plr_owner != NULL)
save.c:      sprintf (buf, "POwn %s~\n", obj->plr_owner);
save.c:      if (obj->objtrig[i] != NULL && obj->objtrig[i]->pIndexData->vnum != obj->pIndexData->obj_trig_vnum[i])
save.c:        sprintf (buf, "OTVnum2 %d\n", obj->objtrig[0]->pIndexData->vnum);
save.c:          if (obj->objtrig[i])
save.c:            sprintf (buf, "%d\n", obj->objtrig[i]->pIndexData->vnum);
save.c:  if (obj->item_type != obj->pIndexData->item_type)
save.c:      sprintf (buf, "Ityp %d\n", obj->item_type);
save.c:  if (obj->weight != obj->pIndexData->weight)
save.c:      sprintf (buf, "Wt   %d\n", obj->weight);
save.c:  if (obj->condition != obj->pIndexData->condition)
save.c:      sprintf (buf, "Cond %d\n", obj->condition);
save.c:  sprintf (buf, "WearL %ld\n", obj->wear_loc);
save.c:  if (obj->level != obj->pIndexData->level)
save.c:      sprintf (buf, "Lev  %d\n", obj->level);
save.c:  if (obj->timer != 0)
save.c:      sprintf (buf, "Time %d\n", obj->timer);
save.c:  sprintf (buf, "Cost %d\n", obj->cost);
save.c:  if (obj->value[0] != obj->pIndexData->value[0]
save.c:      || obj->value[1] != obj->pIndexData->value[1]
save.c:      || obj->value[2] != obj->pIndexData->value[2]
save.c:      || obj->value[3] != obj->pIndexData->value[3]
save.c:      || obj->value[4] != obj->pIndexData->value[4]
save.c:      || obj->value[5] != obj->pIndexData->value[5]
save.c:      || obj->value[6] != obj->pIndexData->value[6]
save.c:      || obj->value[7] != obj->pIndexData->value[7]
save.c:      || obj->value[8] != obj->pIndexData->value[8]
save.c:      || obj->value[9] != obj->pIndexData->value[9]
save.c:      || obj->value[10] != obj->pIndexData->value[10]
save.c:      || obj->value[11] != obj->pIndexData->value[11]
save.c:      || obj->value[12] != obj->pIndexData->value[12]
save.c:	       obj->value[0], obj->value[1], obj->value[2], obj->value[3],
save.c:	       obj->value[4], obj->value[5], obj->value[6], obj->value[7],
save.c:	       obj->value[8], obj->value[9], obj->value[10], obj->value[11], obj->value[12]);
save.c:  switch (obj->item_type)
save.c:      if (obj->value[0] > 0)
save.c:	  sprintf (buf, "Spell 0 '%s'\n", skill_table[obj->value[0]].name);
save.c:      if (obj->value[1] > 0)
save.c:	  sprintf (buf, "Spell 1 '%s'\n", skill_table[obj->value[1]].name);
save.c:      if (obj->value[2] > 0)
save.c:	  sprintf (buf, "Spell 2 '%s'\n", skill_table[obj->value[2]].name);
save.c:      if (obj->value[3] > 0)
save.c:	  sprintf (buf, "Spell 3 '%s'\n", skill_table[obj->value[3]].name);
save.c:      if (obj->value[3] > 0 && obj->value[3] < MAX_SKILL)
save.c:	  sprintf (buf, "Spell 3 '%s'\n", skill_table[obj->value[3]].name);
save.c:  for (paf = obj->affected; paf != NULL; paf = paf->next)
save.c:      for (taf = obj->pIndexData->affected;taf != NULL;taf = taf->next)
save.c:  for (ed = obj->extra_descr; ed != NULL; ed = ed->next)
save.c:  if (obj->next_content != NULL)
save.c:      fwrite_obj (ch, obj->next_content, fp, iNest);
save.c:  if (obj->contains != NULL)
save.c:    fwrite_obj (ch, obj->contains, fp, iNest + 1);
save.c:  if (obj->next_content != NULL)
save.c:    fwrite_objdb (obj->next_content, fp, iNest);
save.c:  fprintf (fp, "Vnum %d\n", obj->pIndexData->vnum);
save.c:  if (obj->enchanted)
save.c:  if (obj->name != obj->pIndexData->name)
save.c:    fprintf (fp, "Name %s~\n", obj->name);
save.c:  if (obj->owner != NULL && obj->owner[0] != '\0')
save.c:    fprintf (fp, "OwnR %s~\n", obj->owner);
save.c:  if (obj->short_descr != obj->pIndexData->short_descr)
save.c:    fprintf (fp, "ShD  %s~\n", obj->short_descr);
save.c:  if (obj->description != obj->pIndexData->description)
save.c:    fprintf (fp, "Desc %s~\n", obj->description);
save.c:       if (obj->extra_flags[i] != obj->pIndexData->extra_flags[i])
save.c:         fprintf (fp, "ExF %d %ld\n", i, obj->extra_flags[i]);
save.c:  if (obj->wear_flags != obj->pIndexData->wear_flags)
save.c:    fprintf (fp, "WeaF %ld\n", obj->wear_flags);
save.c:  if (obj->Class_flags != obj->pIndexData->Class_flags)
save.c:    fprintf (fp, "ClassF %ld\n", obj->Class_flags);
save.c:  if (obj->race_flags != obj->pIndexData->race_flags)
save.c:    fprintf (fp, "RaceF %ld\n", obj->race_flags);
save.c:  if (obj->clan_flags != obj->pIndexData->clan_flags)
save.c:    fprintf (fp, "ClanF %ld\n", obj->clan_flags);
save.c:  if (obj->bs_capacity[0] != 0)
save.c:    fprintf (fp, "Cardslot %d\n", obj->bs_capacity[0]);
save.c:  if (obj->plr_owner != obj->pIndexData->plr_owner)
save.c:    fprintf (fp, "POwn %s~\n", obj->plr_owner);
save.c:    if (obj->objtrig[i] != NULL && obj->objtrig[i]->pIndexData->vnum != obj->pIndexData->obj_trig_vnum[i])
save.c:      fprintf (fp, "OTVnum2 %d\n", obj->objtrig[0]->pIndexData->vnum);
save.c:	if (obj->objtrig[i])
save.c:          fprintf (fp, "%d\n", obj->objtrig[i]->pIndexData->vnum);	   
save.c:  if (obj->item_type != obj->pIndexData->item_type)
save.c:    fprintf (fp, "Ityp %d\n", obj->item_type);
save.c:  if (obj->weight != obj->pIndexData->weight)
save.c:    fprintf (fp, "Wt   %d\n", obj->weight);
save.c:  if (obj->condition != obj->pIndexData->condition)
save.c:    fprintf (fp, "Cond %d\n", obj->condition);
save.c:  fprintf (fp, "WearL %ld\n", obj->wear_loc);
save.c:  if (obj->level != obj->pIndexData->level)
save.c:    fprintf (fp, "Lev  %d\n", obj->level);
save.c:  if (obj->timer != 0)
save.c:    fprintf (fp, "Time %d\n", obj->timer);
save.c:  fprintf (fp, "Cost %d\n", obj->cost);
save.c:  if (obj->value[0] != obj->pIndexData->value[0]
save.c:      || obj->value[1] != obj->pIndexData->value[1]
save.c:      || obj->value[2] != obj->pIndexData->value[2]
save.c:      || obj->value[3] != obj->pIndexData->value[3]
save.c:      || obj->value[4] != obj->pIndexData->value[4]
save.c:      || obj->value[5] != obj->pIndexData->value[5]
save.c:      || obj->value[6] != obj->pIndexData->value[6]
save.c:      || obj->value[7] != obj->pIndexData->value[7]
save.c:      || obj->value[8] != obj->pIndexData->value[8]
save.c:      || obj->value[9] != obj->pIndexData->value[9]
save.c:      || obj->value[10] != obj->pIndexData->value[10]
save.c:      || obj->value[11] != obj->pIndexData->value[11]
save.c:      || obj->value[12] != obj->pIndexData->value[12]
save.c:	     obj->value[0], obj->value[1], obj->value[2], obj->value[3],
save.c:	     obj->value[4], obj->value[5], obj->value[6], obj->value[7],
save.c:	     obj->value[8], obj->value[9], obj->value[10], obj->value[11], obj->value[12]);
save.c:  switch (obj->item_type)
save.c:      if (obj->value[0] > 0)
save.c:	  fprintf (fp, "Spell 0 '%s'\n", skill_table[obj->value[0]].name);
save.c:      if (obj->value[1] > 0)
save.c:	  fprintf (fp, "Spell 1 '%s'\n", skill_table[obj->value[1]].name);
save.c:      if (obj->value[2] > 0)
save.c:	  fprintf (fp, "Spell 2 '%s'\n", skill_table[obj->value[2]].name);
save.c:      if (obj->value[3] > 0)
save.c:	  fprintf (fp, "Spell 3 '%s'\n", skill_table[obj->value[3]].name);
save.c:      fprintf (fp, "Clan %s~\n", get_clan_name (obj->value[1]));
save.c:      if (obj->value[3] > 0 && obj->value[3] < MAX_SKILL)
save.c:	  fprintf (fp, "Spell 3 '%s'\n", skill_table[obj->value[3]].name);
save.c:  for (paf = obj->affected; paf != NULL; paf = paf->next)
save.c:      for (taf = obj->pIndexData->affected;taf != NULL;taf = taf->next)
save.c:  for (ed = obj->extra_descr; ed != NULL; ed = ed->next)
save.c:  if (obj->contains != NULL)
save.c:    fwrite_objdb (obj->contains, fp, iNest + 1);
save.c:	  KEY ("ClanF", obj->clan_flags, fread_flag (sfp));
save.c:	  KEY ("Cardslot", obj->bs_capacity[0], fread_number (sfp));
save.c:	  KEY ("ClanFlags", obj->clan_flags, fread_flag (sfp));
save.c:	  KEY ("ClassF", obj->Class_flags, fread_flag (sfp));
save.c:	  KEY ("ClassFlags", obj->Class_flags, fread_flag (sfp));
save.c:	  KEY ("Cond", obj->condition, fread_flag (sfp));
save.c:	  KEY ("Cost", obj->cost, fread_number (sfp));
save.c:	  KEY ("Desc", obj->description, fread_string (sfp));
save.c:	  KEY ("ExtF", obj->extra_flags[0], fread_number (sfp));
save.c:	    obj->extra_flags[ai] = fread_number (sfp);
save.c:	  KEY ("Name", obj->name, fread_string (sfp));
save.c:	  KEY ("OwnR", obj->owner, fread_string (sfp));
save.c:	  KEY ("RaceF", obj->race_flags, fread_flag (sfp));
save.c:	  KEY ("ShD", obj->short_descr, fread_string (sfp));
save.c:	  KEY ("Time", obj->timer, fread_number (sfp));
save.c:	  KEY ("WeaF", obj->wear_flags, fread_number (sfp));
save.c:  for (obj = object_list; obj; obj = obj->next)
save.c:    if (obj->item_type == ITEM_CTRANSPORT && obj->in_room != NULL)
save.c:  fprintf (fp, "Vnum %d\n", obj->pIndexData->vnum);
save.c:  fprintf (fp, "InRoom %d\n", obj->in_room->vnum);
save.c:  if (obj->name != obj->pIndexData->name)
save.c:    fprintf (fp, "Name %s~\n", obj->name);
save.c:  if (obj->owner != NULL && obj->owner[0] != '\0')
save.c:    fprintf (fp, "OwnR %s~\n", obj->owner);
save.c:  if (obj->short_descr != obj->pIndexData->short_descr)
save.c:    fprintf (fp, "ShD  %s~\n", obj->short_descr);
save.c:  if (obj->description != obj->pIndexData->description)
save.c:    fprintf (fp, "Desc %s~\n", obj->description);
save.c:      if (obj->extra_flags[i] != obj->pIndexData->extra_flags[i])
save.c:        fprintf (fp, "ExF %d %ld\n", i, obj->extra_flags[i]);
save.c:  if (obj->wear_flags != obj->pIndexData->wear_flags)
save.c:    fprintf (fp, "WeaF %ld\n", obj->wear_flags);
save.c:  if (obj->Class_flags != obj->pIndexData->Class_flags)
save.c:    fprintf (fp, "ClassF %ld\n", obj->Class_flags);
save.c:  if (obj->race_flags != obj->pIndexData->race_flags)
save.c:    fprintf (fp, "RaceF %ld\n", obj->race_flags);
save.c:  if (obj->clan_flags != obj->pIndexData->clan_flags)
save.c:    fprintf (fp, "ClanF %ld\n", obj->clan_flags);
save.c:  if (obj->bs_capacity[0] != 0)
save.c:    fprintf (fp, "Cardslot %d\n", obj->bs_capacity[0]);
save.c:  if (obj->item_type != obj->pIndexData->item_type)
save.c:    fprintf (fp, "Ityp %d\n", obj->item_type);
save.c:  if (obj->weight != obj->pIndexData->weight)
save.c:    fprintf (fp, "Wt   %d\n", obj->weight);
save.c:  if (obj->condition != obj->pIndexData->condition)
save.c:    fprintf (fp, "Cond %d\n", obj->condition);
save.c:  fprintf (fp, "WearL %ld\n", obj->wear_loc);
save.c:  if (obj->level != obj->pIndexData->level)
save.c:    fprintf (fp, "Lev  %d\n", obj->level);
save.c:  if (obj->timer != 0)
save.c:    fprintf (fp, "Time %d\n", obj->timer);
save.c:  fprintf (fp, "Cost %d\n", obj->cost);
save.c:  if (obj->value[0] != obj->pIndexData->value[0]
save.c:      || obj->value[1] != obj->pIndexData->value[1]
save.c:      || obj->value[2] != obj->pIndexData->value[2]
save.c:      || obj->value[3] != obj->pIndexData->value[3]
save.c:      || obj->value[4] != obj->pIndexData->value[4]
save.c:      || obj->value[5] != obj->pIndexData->value[5]
save.c:      || obj->value[6] != obj->pIndexData->value[6]
save.c:      || obj->value[7] != obj->pIndexData->value[7]
save.c:      || obj->value[8] != obj->pIndexData->value[8]
save.c:      || obj->value[9] != obj->pIndexData->value[9]
save.c:      || obj->value[10] != obj->pIndexData->value[10]
save.c:      || obj->value[11] != obj->pIndexData->value[11]
save.c:      || obj->value[12] != obj->pIndexData->value[12]
save.c:	     obj->value[0], obj->value[1], obj->value[2], obj->value[3],
save.c:	     obj->value[4], obj->value[5], obj->value[6], obj->value[7],
save.c:	     obj->value[8], obj->value[9], obj->value[10], obj->value[11], obj->value[12]);
save.c:  for (ed = obj->extra_descr; ed != NULL; ed = ed->next)
save.c:      obj->name = str_dup ("");
save.c:      obj->short_descr = str_dup ("");
save.c:      obj->description = str_dup ("");
save.c:      obj->extra_descr = NULL;
save.c:	      paf->next = obj->affected;
save.c:	      obj->affected = paf;
save.c:	      paf->next = obj->affected;
save.c:	      obj->affected = paf;
save.c:	  KEY ("Cardslot", obj->bs_capacity[0], fread_number (fp));
save.c:	  KEY ("ClanFlags", obj->clan_flags, fread_flag (fp));
save.c:	  KEY ("ClanF", obj->clan_flags, fread_flag (fp));
save.c:	  KEY ("ClassFlags", obj->Class_flags, fread_flag (fp));
save.c:	  KEY ("ClassF", obj->Class_flags, fread_flag (fp));
save.c:	  KEY ("Cond", obj->condition, fread_number (fp));
save.c:	  KEY ("Cost", obj->cost, fread_number (fp));
save.c:	  KEY ("Description", obj->description, fread_string (fp));
save.c:	  KEY ("Desc", obj->description, fread_string (fp));
save.c:	      obj->enchanted = TRUE;
save.c:	  KEY ("ExtraFlags", obj->extra_flags[0], fread_number (fp));
save.c:	  KEY ("ExtF", obj->extra_flags[0], fread_number (fp));
save.c:		  obj->extra_flags[ai] = fread_number (fp);
save.c:	      cur = obj->extra_descr;
save.c:		  ed->next = obj->extra_descr;
save.c:		  obj->extra_descr = ed;
save.c:	      if (!fNest || !fVnum || obj->pIndexData == NULL)
save.c:		      wear = obj->wear_loc;
save.c:		      obj = create_object (obj->pIndexData, 0);
save.c:		      obj->wear_loc = wear;
save.c:		      obj->condition = 100;
save.c:		  if (obj->condition == 0)
save.c:		    obj->condition = 100;
save.c:	  KEY ("ItemType", obj->item_type, fread_number (fp));
save.c:	  KEY ("Ityp", obj->item_type, fread_number (fp));
save.c:	  KEY ("Level", obj->level, fread_number (fp));
save.c:	  KEY ("Lev", obj->level, fread_number (fp));
save.c:	  KEY ("Name", obj->name, fread_string (fp));
save.c:	  KEY ("OwnR", obj->owner, fread_string (fp));
save.c:	      if (obj->pIndexData != NULL)
save.c:		if (obj->objtrig[i])
save.c:  	  	  free_ot(obj->objtrig[i]);
save.c:		  obj->objtrig[i] = new_ot(tempi);
save.c:		  if (obj->objtrig[i])
save.c:		    obj->objtrig[i]->obj_on = obj;
save.c:	    if (obj->objtrig[0] == NULL)
save.c:	      obj->objtrig[0] = new_ot(tempi);
save.c:	      if (obj->objtrig[0])
save.c:	        obj->objtrig[0]->obj_on = obj;
save.c:	        obj->objtrig[i] = NULL;
save.c:              free_ot(obj->objtrig[0]);
save.c:              obj->objtrig[0] = new_ot(tempi);
save.c:	      if (obj->objtrig[0])
save.c:                obj->objtrig[0]->obj_on = obj;
save.c:                obj->objtrig[i] = NULL;
save.c:	  KEY ("POwn", obj->plr_owner, fread_string (fp));
save.c:	  KEY ("RaceFlags", obj->race_flags, fread_flag (fp));
save.c:	  KEY ("RaceF", obj->race_flags, fread_flag (fp));
save.c:	  KEY ("ShortDescr", obj->short_descr, fread_string (fp));
save.c:	  KEY ("ShD", obj->short_descr, fread_string (fp));
save.c:		  obj->value[iValue] = sn;
save.c:	  KEY ("Timer", obj->timer, fread_number (fp));
save.c:	  KEY ("Time", obj->timer, fread_number (fp));
save.c:	      obj->value[0] = fread_number (fp);
save.c:	      obj->value[1] = fread_number (fp);
save.c:	      obj->value[2] = fread_number (fp);
save.c:	      obj->value[3] = fread_number (fp);
save.c:	      if (obj->item_type == ITEM_WEAPON && obj->value[0] == 0)
save.c:		obj->value[0] = obj->pIndexData->value[0];
save.c:	      obj->value[0] = fread_number (fp);
save.c:	      obj->value[1] = fread_number (fp);
save.c:	      obj->value[2] = fread_number (fp);
save.c:	      obj->value[3] = fread_number (fp);
save.c:	      obj->value[4] = fread_number (fp);
save.c:	      obj->value[5] = fread_number (fp);
save.c:	      obj->value[6] = fread_number (fp);
save.c:              obj->value[0] = fread_number (fp);
save.c:              obj->value[1] = fread_number (fp);
save.c:              obj->value[2] = fread_number (fp);
save.c:              obj->value[3] = fread_number (fp);
save.c:              obj->value[4] = fread_number (fp);
save.c:              obj->value[5] = fread_number (fp);
save.c:              obj->value[6] = fread_number (fp);
save.c:	      obj->value[7] = fread_number (fp);
save.c:	      obj->value[8] = fread_number (fp);
save.c:	      obj->value[9] = fread_number (fp);
save.c:	      obj->value[10] = fread_number (fp);
save.c://	      obj->value[11] = fread_number (fp);
save.c://	      obj->value[12] = fread_number (fp);
save.c:              obj->value[0] = fread_number (fp);
save.c:              obj->value[1] = fread_number (fp);
save.c:              obj->value[2] = fread_number (fp);
save.c:              obj->value[3] = fread_number (fp);
save.c:              obj->value[4] = fread_number (fp);
save.c:              obj->value[5] = fread_number (fp);
save.c:              obj->value[6] = fread_number (fp);
save.c:              obj->value[7] = fread_number (fp);
save.c:              obj->value[8] = fread_number (fp);
save.c:              obj->value[9] = fread_number (fp);
save.c:              obj->value[10] = fread_number (fp);
save.c:              obj->value[11] = fread_number (fp);
save.c:              obj->value[12] = fread_number (fp);
save.c:	      if ((obj->pIndexData = get_obj_index (vnum)) == NULL)
save.c:	  KEY ("WearFlags", obj->wear_flags, fread_number (fp));
save.c:	  KEY ("WeaF", obj->wear_flags, fread_number (fp));
save.c:	  KEY ("WearLoc", obj->wear_loc, fread_number (fp));
save.c:	  KEY ("WearL", obj->wear_loc, fread_number (fp));
save.c:	  KEY ("Weight", obj->weight, fread_number (fp));
save.c:	  KEY ("Wt", obj->weight, fread_number (fp));
save.c:                    obj->wear_loc = -1;
save.c:				  obj->wear_loc = wear_conversion_table[i].wear_flag;
save.c:      obj->name = str_dup ("");
save.c:      obj->short_descr = str_dup ("");
save.c:      obj->description = str_dup ("");
save.c:	      paf->next = obj->affected;
save.c:	      obj->affected = paf;
save.c:	      paf->next = obj->affected;
save.c:	      obj->affected = paf;
save.c:	  KEY ("Cardslot", obj->bs_capacity[0], fread_number (fp));
save.c:	  KEY ("ClanFlags", obj->clan_flags, fread_flag (fp));
save.c:	  KEY ("ClanF", obj->clan_flags, fread_flag (fp));
save.c:	  KEY ("ClassFlags", obj->Class_flags, fread_flag (fp));
save.c:	  KEY ("ClassF", obj->Class_flags, fread_flag (fp));
save.c:	  KEY ("Cond", obj->condition, fread_number (fp));
save.c:	  KEY ("Cost", obj->cost, fread_number (fp));
save.c:		obj->value[1] = slot;
save.c:	  KEY ("Description", obj->description, fread_string (fp));
save.c:	  KEY ("Desc", obj->description, fread_string (fp));
save.c:	      obj->enchanted = TRUE;
save.c:	  KEY ("ExtraFlags", obj->extra_flags[0], fread_number (fp));
save.c:	  KEY ("ExtF", obj->extra_flags[0], fread_number (fp));
save.c:		  obj->extra_flags[ai] = fread_number (fp);
save.c:	      ed->next = obj->extra_descr;
save.c:	      obj->extra_descr = ed;
save.c:	      if (!fNest || !fVnum || obj->pIndexData == NULL)
save.c:		      obj->condition = 100;
save.c:		      wear = obj->wear_loc;
save.c:		      obj = create_object (obj->pIndexData, 0);
save.c:		      obj->wear_loc = wear;
save.c:		  if (obj->condition == 0)
save.c:		    obj->condition = 100;
save.c:	  KEY ("ItemType", obj->item_type, fread_number (fp));
save.c:	  KEY ("Ityp", obj->item_type, fread_number (fp));
save.c:	  KEY ("Level", obj->level, fread_number (fp));
save.c:	  KEY ("Lev", obj->level, fread_number (fp));
save.c:	  KEY ("Name", obj->name, fread_string (fp));
save.c:	  KEY ("OwnR", obj->owner, fread_string (fp));
save.c:	      if (obj->pIndexData != NULL)
save.c:               if (obj->objtrig[i])
save.c:                 free_ot(obj->objtrig[i]);
save.c:                 obj->objtrig[i] = new_ot(tempi);
save.c:		 if (obj->objtrig[i])
save.c:                   obj->objtrig[i]->obj_on = obj;
save.c:	    if (obj->objtrig[0] == NULL)
save.c:	      obj->objtrig[0] = new_ot(tempi);
save.c:	      if (obj->objtrig[0])
save.c:	        obj->objtrig[0]->obj_on = obj;
save.c:		obj->objtrig[i] = NULL;
save.c:	      free_ot(obj->objtrig[0]);
save.c:	      obj->objtrig[0] = new_ot(tempi);
save.c:	      if (obj->objtrig[0])
save.c: 	        obj->objtrig[0]->obj_on = obj;
save.c:                 obj->objtrig[i] = NULL;	      
save.c:	  KEY ("POwn", obj->plr_owner, fread_string (fp));
save.c:	  KEY ("RaceFlags", obj->race_flags, fread_flag (fp));
save.c:	  KEY ("RaceF", obj->race_flags, fread_flag (fp));
save.c:	  KEY ("ShortDescr", obj->short_descr, fread_string (fp));
save.c:	  KEY ("ShD", obj->short_descr, fread_string (fp));
save.c:		  obj->value[iValue] = sn;
save.c:	  KEY ("Timer", obj->timer, fread_number (fp));
save.c:	  KEY ("Time", obj->timer, fread_number (fp));
save.c:	      obj->value[0] = fread_number (fp);
save.c:	      obj->value[1] = fread_number (fp);
save.c:	      obj->value[2] = fread_number (fp);
save.c:	      obj->value[3] = fread_number (fp);
save.c:	      if (obj->item_type == ITEM_WEAPON && obj->value[0] == 0)
save.c:		obj->value[0] = obj->pIndexData->value[0];
save.c:	      obj->value[0] = fread_number (fp);
save.c:	      obj->value[1] = fread_number (fp);
save.c:	      obj->value[2] = fread_number (fp);
save.c:	      obj->value[3] = fread_number (fp);
save.c:	      obj->value[4] = fread_number (fp);
save.c:	      obj->value[5] = fread_number (fp);
save.c:	      obj->value[6] = fread_number (fp);
save.c:	      obj->value[0] = fread_number (fp);
save.c:	      obj->value[1] = fread_number (fp);
save.c:	      obj->value[2] = fread_number (fp);
save.c:	      obj->value[3] = fread_number (fp);
save.c:	      obj->value[4] = fread_number (fp);
save.c:	      obj->value[5] = fread_number (fp);
save.c:	      obj->value[6] = fread_number (fp);
save.c:	      obj->value[7] = fread_number (fp);
save.c:	      obj->value[8] = fread_number (fp);
save.c:	      obj->value[9] = fread_number (fp);
save.c:	      obj->value[10] = fread_number (fp);
save.c://	      obj->value[11] = fread_number (fp);
save.c://	      obj->value[12] = fread_number (fp);
save.c:              obj->value[0] = fread_number (fp);
save.c:              obj->value[1] = fread_number (fp);
save.c:              obj->value[2] = fread_number (fp);
save.c:              obj->value[3] = fread_number (fp);
save.c:              obj->value[4] = fread_number (fp);
save.c:              obj->value[5] = fread_number (fp);
save.c:              obj->value[6] = fread_number (fp);
save.c:              obj->value[7] = fread_number (fp);
save.c:              obj->value[8] = fread_number (fp);
save.c:              obj->value[9] = fread_number (fp);
save.c:              obj->value[10] = fread_number (fp);
save.c:              obj->value[11] = fread_number (fp);
save.c:              obj->value[12] = fread_number (fp);
save.c:	      if ((obj->pIndexData = get_obj_index (vnum)) == NULL)
save.c:	  KEY ("WearFlags", obj->wear_flags, fread_number (fp));
save.c:	  KEY ("WeaF", obj->wear_flags, fread_number (fp));
save.c:	  KEY ("WearLoc", obj->wear_loc, fread_number (fp));
save.c:	  KEY ("WearL", obj->wear_loc, fread_number (fp));
save.c:	  KEY ("Weight", obj->weight, fread_number (fp));
save.c:	  KEY ("Wt", obj->weight, fread_number (fp));
save.c:			  obj->wear_loc = -1;
save.c:				  obj->wear_loc = wear_conversion_table[i].wear_flag;
save.c:	  bug ("fread_objdb() - no match. - vnum %d", obj->pIndexData->vnum);
songs.c:  if (iobj == NULL || iobj->item_type != ITEM_INSTRUMENT)
songs.c:	  bonus = 0 - iobj->level;
songs.c:	bonus = iobj->level;
songs.c:      sprintf (tcbuf, "You drop %s.\n\r", obj->short_descr);
songs.c:      sprintf (tcbuf, "$n drops %s.", obj->short_descr);
special.c:       && obj->pIndexData->vnum == OBJ_VNUM_WHISTLE)
special.c:	  && obj->pIndexData->vnum == OBJ_VNUM_WHISTLE))
special.c:	  obj_next = obj->next_content;
special.c:                  && obj->item_type == ITEM_LIGHT
special.c:	    && obj->value[2] != 0 && ch->in_room != NULL))
special.c:      obj_next = obj->next_content;
special.c:      if (IS_CLASS(ch,PC_CLASS_REAVER) && (obj->wear_loc == WEAR_WIELD_L || obj->wear_loc == WEAR_WIELD_R))
special.c:      if (obj->wear_loc != WEAR_NONE)
special.c:                  && obj->item_type == ITEM_LIGHT
special.c:	    && obj->value[2] != 0 && ch->in_room != NULL))
special.c:      obj_next = obj->next_content;
special.c:      if (IS_CLASS(ch,PC_CLASS_REAVER) && (obj->wear_loc == WEAR_WIELD_L || obj->wear_loc == WEAR_WIELD_R))
special.c:      if (obj->wear_loc != WEAR_NONE)
special.c:                  && obj->item_type == ITEM_LIGHT
special.c:	    && obj->value[2] != 0 && ch->in_room != NULL))
special.c:      obj_next = obj->next_content;
special.c:      if (IS_CLASS(ch,PC_CLASS_REAVER) && (obj->wear_loc == WEAR_WIELD_L || obj->wear_loc == WEAR_WIELD_R))
special.c:      if (obj->wear_loc != WEAR_NONE)
special.c:                  && obj->item_type == ITEM_LIGHT
special.c:	    && obj->value[2] != 0 && ch->in_room != NULL))
special.c:      obj_next = obj->next_content;
special.c:      if (IS_CLASS(ch,PC_CLASS_REAVER) && (obj->wear_loc == WEAR_WIELD_L || obj->wear_loc == WEAR_WIELD_R))
special.c:      if (obj->wear_loc != WEAR_NONE)
special.c:                  && obj->item_type == ITEM_LIGHT
special.c:            && obj->value[2] != 0 && ch->in_room != NULL))
special.c:      obj_next = obj->next_content;
special.c:      if (IS_CLASS(ch,PC_CLASS_REAVER) && (obj->wear_loc == WEAR_WIELD_L || obj->wear_loc == WEAR_WIELD_R))
special.c:      if (obj->wear_loc != WEAR_NONE)
special.c:                  && obj->item_type == ITEM_LIGHT
special.c:            && obj->value[2] != 0 && ch->in_room != NULL))
special.c:      obj_next = obj->next_content;
special.c:      if (IS_CLASS(ch,PC_CLASS_REAVER) && (obj->wear_loc == WEAR_WIELD_L || obj->wear_loc == WEAR_WIELD_R))
special.c:      if (obj->wear_loc != WEAR_NONE)
special.c:                  && obj->item_type == ITEM_LIGHT
special.c:            && obj->value[2] != 0 && ch->in_room != NULL))
special.c:      obj_next = obj->next_content;
special.c:      if (IS_CLASS(ch,PC_CLASS_REAVER) && (obj->wear_loc == WEAR_WIELD_L || obj->wear_loc == WEAR_WIELD_R))
special.c:      if (obj->wear_loc != WEAR_NONE)
special.c:      obj_next = obj->next_content;
special.c:      if (IS_CLASS(ch,PC_CLASS_REAVER) && (obj->wear_loc == WEAR_WIELD_L || obj->wear_loc == WEAR_WIELD_R))
special.c:      if (obj->wear_loc != WEAR_NONE)
special.c:      for (obj = ch->carrying;obj != NULL;obj = obj->next_content)
special.c:      for (obj = ch->carrying;obj != NULL;obj = obj->next_content)
special.c:	  case 1: sprintf(buf,"`oI have ``%s`o for sale!",obj->short_descr);
special.c:	  case 2: sprintf(buf,"`oI am currently selling ``%s`o, and I KNOW you want to buy it.",obj->short_descr);break;
special.c:	  case 3: sprintf(buf,"`oI have ``%s `oin stock and it's priced to move!",obj->short_descr);break;
special.c:	  default: sprintf(buf,"%s `ocan be found in my wonderful store.  Won't you please buy one?",obj->short_descr);break;
trade_skills.c:  if (obj->pIndexData->vnum == OBJ_VNUM_STICKS)
trade_skills.c:          for (obj = ch->carrying; obj != NULL; obj = obj->next_content)
trade_skills.c:            if (obj->pIndexData->vnum == OBJ_VNUM_STICKS)
trade_skills.c:          obj->condition =
trade_skills.c:          if (obj->condition > 90)
trade_skills.c:          else if (obj->condition > 50)
trade_skills.c:          for (obj = ch->carrying; obj != NULL; obj = obj->next_content)
trade_skills.c:            if (obj->pIndexData->vnum == OBJ_VNUM_STICKS)
trade_skills.c:          obj->condition =
trade_skills.c:          if (obj->condition > 90)
trade_skills.c:          else if (obj->condition > 50)
trade_skills.c:  else if (obj->item_type == ITEM_WOOD)
trade_skills.c:      obj2->value[0] = obj->value[0]; //Type of wood object is made from
trade_skills.c:      obj2->weight = obj->weight*.66;
trade_skills.c:      obj->condition = number_range (get_skill (ch, gsn_woodworking), 100);
trade_skills.c:	obj2->value[0] = obj->value[0]; //Type of wood object is made from
trade_skills.c:	obj2->weight = obj->weight*.66;
trade_skills.c:	obj2->timer = obj->weight*200;
trade_skills.c:	obj->condition = number_range (get_skill (ch, gsn_woodworking), 100);
trade_skills.c:      weapon->value[1] = obj->value[0];
trade_skills.c:      sprintf (buf, "You combine %s and %s into %s and begin carving.\n\r",obj->short_descr,obj2->short_descr,weapon->short_descr);
trade_skills.c:      sprintf (buf, "$n combines %s and %s into %s and begins carving.",obj->short_descr,obj2->short_descr,weapon->short_descr);
trade_skills.c:      weapon->value[1] = obj->value[0];
trade_skills.c:      sprintf(buf, "You begin carving %s into %s.\n\r",obj->short_descr,weapon->short_descr);
trade_skills.c:      sprintf(buf, "$n begins carving %s into %s.",obj->short_descr,weapon->short_descr);
trade_skills.c:       if (obj->item_type != ITEM_WOODEN_INCONSTRUCTION)
trade_skills.c:	if (obj->value[5] != -1)
trade_skills.c:	cptr=strchr(obj->short_descr,'\'');
trade_skills.c:	if (obj->pIndexData->vnum != OBJ_VNUM_PLAQUE)
trade_skills.c:	  sprintf(buf,"`dA wooden '`h%s`d' made of %s wood is here.``",arg,tree_table[obj->value[0]].name);
trade_skills.c:	free_string(obj->description);
trade_skills.c:	obj->description = str_dup(buf);
trade_skills.c:	if (obj->pIndexData->vnum != OBJ_VNUM_PLAQUE)
trade_skills.c:	    sprintf(buf,"`da wooden '`h%s`d' made of %s wood``",arg,tree_table[obj->value[0]].name);
trade_skills.c:	    free_string(obj->short_descr);
trade_skills.c:	    obj->short_descr = str_dup(buf);
trade_skills.c:	    sprintf(buf,"figurine %s %s",tree_table[obj->value[0]].name, arg);
trade_skills.c:	    free_string(obj->name);
trade_skills.c:	    obj->name = str_dup(buf);
trade_skills.c:	chance += obj->weight/10;
trade_skills.c:	switch (obj->value[0])
trade_skills.c:	switch(attack_table[obj->value[3]].damage)
trade_skills.c:	if (!str_cmp(attack_table[obj->value[3]].noun,"chop"))
trade_skills.c:	if (IS_SET(obj->value[4],WEAPON_SHARP))
trade_skills.c:	switch (obj->value[0])
trade_skills.c:	switch(attack_table[obj->value[3]].damage)
trade_skills.c:	if (IS_SET(obj->value[4],WEAPON_SHARP))
trade_skills.c:	    obj->value[0] = tree->value[0]; //Type of tree
trade_skills.c:	    obj->weight = tree_table[tree->value[0]].weight*10+number_range(0,3);
trade_skills.c:	    sprintf (buf, obj->short_descr, tree_table[tree->value[0]].name);
trade_skills.c:	    free_string (obj->short_descr);
trade_skills.c:	    obj->short_descr = str_dup (buf);
trade_skills.c:	    sprintf (buf, obj->description, tree_table[tree->value[0]].name);
trade_skills.c:	    free_string (obj->description);
trade_skills.c:	    obj->description = str_dup (buf);
trade_skills.c:	    free_string (obj->name);
trade_skills.c:	    obj->name = str_dup (buf);
trade_skills.c:	    obj->condition = 50;
trade_skills.c:		obj->value[0] = tree->value[0]; //Type of tree
trade_skills.c:		free_string (obj->short_descr);
trade_skills.c:		obj->short_descr = str_dup (buf);
trade_skills.c:		free_string (obj->description);
trade_skills.c:		obj->description = str_dup (buf);
trade_skills.c:		free_string (obj->name);
trade_skills.c:		obj->name = str_dup (buf);
trade_skills.c:		obj->condition = 5;
trade_skills.c:	if (++d->character->pcdata->trade_skill_obj->value[3] >= wooden_obj_table[d->character->pcdata->trade_skill_obj->value[0]].updates_to_complete)
trade_skills.c:  	  switch (d->character->pcdata->trade_skill_obj->value[0])
trade_skills.c:              obj->condition = number_range (get_skill (d->character, gsn_woodworking), 100);
trade_skills.c:	      obj->weight = .66*10*((tree_table[d->character->pcdata->trade_skill_obj->value[1]].weight + tree_table[d->character->pcdata->trade_skill_obj->value[2]].weight));
trade_skills.c:	      obj->value[3] = 100+tree_table[d->character->pcdata->trade_skill_obj->value[1]].hp_heal_bonus + tree_table[d->character->pcdata->trade_skill_obj->value[2]].hp_heal_bonus;
trade_skills.c:	      obj->value[4] = 100+tree_table[d->character->pcdata->trade_skill_obj->value[1]].mana_heal_bonus + tree_table[d->character->pcdata->trade_skill_obj->value[2]].mana_heal_bonus;
trade_skills.c:	      if (d->character->pcdata->trade_skill_obj->value[1]  != d->character->pcdata->trade_skill_obj->value[2])
trade_skills.c:		sprintf (buf, "a chair made of %s and %s wood", tree_table[d->character->pcdata->trade_skill_obj->value[1]].name, tree_table[d->character->pcdata->trade_skill_obj->value[2]].name);
trade_skills.c:		sprintf (buf, "a chair made of %s wood", tree_table[d->character->pcdata->trade_skill_obj->value[1]].name);
trade_skills.c:	      free_string (obj->short_descr);
trade_skills.c:	      obj->short_descr = str_dup (buf);
trade_skills.c:	      if (d->character->pcdata->trade_skill_obj->value[1] != d->character->pcdata->trade_skill_obj->value[2])
trade_skills.c:                sprintf (buf, "A chair made of %s and %s wood, marked with the sign of '%s'", tree_table[d->character->pcdata->trade_skill_obj->value[1]].name, tree_table[d->character->pcdata->trade_skill_obj->value[2]].name, d->character->name);
trade_skills.c:                sprintf (buf, "A chair made of %s wood, marked with the sign of '%s'", tree_table[d->character->pcdata->trade_skill_obj->value[1]].name,d->character->name);
trade_skills.c:	      free_string (obj->description);
trade_skills.c:	      obj->description = str_dup (buf);
trade_skills.c:	      if (d->character->pcdata->trade_skill_obj->value[1] != d->character->pcdata->trade_skill_obj->value[2])
trade_skills.c:		sprintf (buf, "chair %s %s",  tree_table[d->character->pcdata->trade_skill_obj->value[1]].name, tree_table[d->character->pcdata->trade_skill_obj->value[2]].name);
trade_skills.c:	      else  sprintf (buf, "chair %s", tree_table[d->character->pcdata->trade_skill_obj->value[1]].name);
trade_skills.c:	      free_string (obj->name);
trade_skills.c:	      obj->name = str_dup (buf);
trade_skills.c:		  switch (d->character->pcdata->trade_skill_obj->value[i+1])
trade_skills.c:		    case TREE_TYPE_JEWELWOOD: obj->cost += 3500;break;
trade_skills.c:		    case TREE_TYPE_RISIRIEL: obj->cost += 3000;break;
trade_skills.c:		    case TREE_TYPE_BARBVINE: obj->cost += 50;break;
trade_skills.c:		    default: obj->cost = 2000;break;
trade_skills.c:	    obj->condition = number_range (get_skill (d->character, gsn_woodworking), 100);
trade_skills.c:	    obj->weight = .40*(tree_table[d->character->pcdata->trade_skill_obj->value[1]].weight);
trade_skills.c:	    switch (d->character->pcdata->trade_skill_obj->value[1])
trade_skills.c:	      case TREE_TYPE_MOONBLOSSOM: obj->value[0] = 100;break;
trade_skills.c:	      case TREE_TYPE_JEWELWOOD: obj->value[0] = 10;break;
trade_skills.c:	      case TREE_TYPE_SLIMEWOOD: obj->value[0] = 50;break;
trade_skills.c:	      case TREE_TYPE_RISIRIEL: obj->value[0] = 150;break;
trade_skills.c:	      case TREE_TYPE_HELLROOT: obj->value[0] = 210;break;
trade_skills.c:	      case TREE_TYPE_BARBVINE: obj->value[0] = 170;break;
trade_skills.c:	      default: obj->value[0] = 110;break;
trade_skills.c:	    sprintf (buf, "`da cup made of %s wood``", tree_table[d->character->pcdata->trade_skill_obj->value[1]].name);
trade_skills.c:	    free_string (obj->short_descr);
trade_skills.c:	    obj->short_descr = str_dup (buf);
trade_skills.c:	    sprintf (buf, "`dA cup made of %s wood, marked by the sign of '%s'.``", tree_table[d->character->pcdata->trade_skill_obj->value[1]].name, d->character->name);
trade_skills.c:	    free_string (obj->description);
trade_skills.c:	    obj->description = str_dup (buf);
trade_skills.c:	    sprintf (buf, "%s cup", tree_table[d->character->pcdata->trade_skill_obj->value[1]].name);
trade_skills.c:	    free_string (obj->name);
trade_skills.c:	    obj->name = str_dup (buf);
trade_skills.c:  if (obj->item_type != ITEM_TREE)
trade_skills.c:  if (IS_SET(obj->value[4],TREE_VALUE_FALLEN))
trade_skills.c:  if (obj->item_type != ITEM_TREE)
trade_skills.c:  if (!IS_SET(obj->value[4],TREE_VALUE_FALLEN))
trade_skills.c:  if (IS_SET(obj->value[4],TREE_VALUE_ROTTEN) || obj->value[3] <= 0)
trade_skills.c:  if (obj->pIndexData->vnum != OBJ_VNUM_PLAQUE)
transport.c:	for (obj = room_link->contents; obj; obj = obj->next_content)
transport.c:		this_weight += obj->weight;
traps.c:	for (ed = obj->extra_descr; ed; ed = ed->next)
traps.c:	for (ed = obj->extra_descr; ed; ed = ed->next)
traps.c:		for (thing = obj->contains; thing != NULL; thing= next_thing)
traps.c:	if (IS_SET(obj->value[12],TFLAG_SNARE))
traps.c:		af.level = obj->level;
traps.c:	if (IS_SET(obj->value[12],TFLAG_POISON))
traps.c:	  if (saves_spell (obj->level, victim, DAM_POISON))
traps.c:	  af.level = obj->level;
traps.c:	  af.duration = obj->level;
traps.c:	  if (obj->set_by != NULL)
traps.c:		  af.comp_name = str_dup (obj->set_by->name);
traps.c:	if (IS_SET(obj->value[12],TFLAG_DISORIENT))
traps.c:	  af.level = obj->level;
traps.c:	if (IS_SET(obj->value[12],TFLAG_BEE))
traps.c:	 if (obj->value[6])
traps.c:		pMobIndex = get_mob_index(obj->value[6]);
traps.c:	if (obj->set_by == NULL)
traps.c:	    ch = obj->set_by;
traps.c:	if (IS_SET(obj->value[12],TFLAG_EXCELLENT))
traps.c:	  dam = (dice(obj->value[1],obj->value[2])+obj->value[3])*1.5;
traps.c:	  dam = (dice(obj->value[1],obj->value[2])+obj->value[3]);
traps.c:	damage (ch, victim, dam , 0 ,attack_table[obj->value[8]].damage , FALSE);
traps.c:	if (IS_SET(obj->value[12],TFLAG_KNOCK))
traps.c:	 if ( victim == NULL || IS_IMMORTAL(victim) || (obj->item_type != ITEM_ROOM_TRAP  && obj->item_type != ITEM_OBJ_TRAP && obj->item_type != ITEM_PORTAL_TRAP ) || IS_NPC(victim) || (!((victim->pcdata->loner || victim->clan != CLAN_BOGUS)) &&(obj->set_by != NULL)) )
traps.c:	 if (obj->set_by != NULL && obj->set_by == victim)
traps.c:	 if (obj->value[0] == TRAP_R_SPELL || obj->value[0] == TRAP_O_SPELL|| obj->value[0] == TRAP_P_SPELL)
traps.c:	 	if (skill_table[obj->value[1]].spell_fun == NULL)
traps.c:		if (obj->set_by != NULL)
traps.c:			mob->name = strdup(obj->set_by->name);
traps.c:		mob->short_descr = strdup(obj->short_descr);	 
traps.c:		mob->level = obj->value[2];
traps.c:		(*skill_table[obj->value[1]].spell_fun) (obj->value[1], obj->value[2], mob, victim, skill_table[obj->value[1]].target);
traps.c:		if ( IS_SET(obj->value[12], TFLAG_AREA))  
traps.c:			  		if ( !IS_NPC(vch) && (vch->pcdata->loner || vch->clan != CLAN_BOGUS || obj->set_by == NULL)) 
traps.c:	 if (obj->item_type == ITEM_ROOM_TRAP || obj->item_type == ITEM_PORTAL_TRAP)
traps.c:	 else if (obj->item_type == ITEM_OBJ_TRAP)
traps.c:    for (obj = ch->in_room->contents; obj != NULL; obj = obj->next_content)
traps.c:      if ( (obj->item_type == ITEM_ROOM_TRAP || obj->item_type == ITEM_PORTAL_TRAP) && IS_SET(obj->extra_flags[1],ITEM_WIZI))
traps.c:    for (obj = container->contains; obj != NULL; obj = obj->next_content)
traps.c:      if ( obj->item_type == ITEM_OBJ_TRAP && IS_SET(obj->extra_flags[1],ITEM_WIZI))
traps.c:if (obj->item_type == ITEM_OBJ_TRAP || obj->item_type == ITEM_ROOM_TRAP || obj->item_type ==
traps.c:                if (number_percent () < (get_skill (ch, gsn_disarm_traps)*.75+ (get_curr_stat (ch, STAT_DEX)- (obj->value[5]/2))) )
traps.c:                        REMOVE_BIT(obj->extra_flags[1],ITEM_WIZI);  // Trap is not active 
traps.c:                        if (obj->set_by == NULL)
traps.c:			         if (obj->item_type == ITEM_ROOM_TRAP)
traps.c:			         else if (obj->item_type == ITEM_OBJ_TRAP)
traps.c:  				  if (obj->set_by != NULL)
traps.c:				        if (obj == obj->set_by->trap_list)
traps.c:				                obj->set_by->trap_list = obj->next_trap;
traps.c:			                for (prev = obj->set_by->trap_list; prev != NULL; prev = prev->next_trap)
traps.c:		                                prev->next_trap = obj->next_trap;
traps.c:                        if (obj->item_type == ITEM_ROOM_TRAP)
traps.c:		        else if (obj->item_type == ITEM_OBJ_TRAP)
traps.c:  if (!strcmp(arg,"object") &&  obj->item_type != ITEM_OBJ_TRAP  )
traps.c:  if (!strcmp(arg,"room") &&  obj->item_type != ITEM_ROOM_TRAP )
traps.c:	if (obj->item_type != ITEM_PORTAL_TRAP )
traps.c:		obj->value[9] = flag_value (dir_flags, arg3); 
traps.c:	  	obj->value[7] = flag_value(pact_flags,arg3);
traps.c:if (obj->item_type == ITEM_OBJ_TRAP || obj->item_type == ITEM_ROOM_TRAP || obj->item_type == ITEM_PORTAL_TRAP ) 	
traps.c:	if (IS_SET(obj->extra_flags[1],ITEM_WIZI)) 
traps.c:		if (number_percent () < (get_skill (ch, gsn_create_traps)*.75+ (get_curr_stat (ch, STAT_DEX)- (obj->value[5]/2))) )
traps.c:			obj->value[5] = get_curr_stat (ch,STAT_DEX);
traps.c:				SET_BIT(obj->value[12],TFLAG_NODISARM);
traps.c:				SET_BIT(obj->value[12],TFLAG_EXCELLENT);
traps.c:				obj->value[5] = UMIN(obj->value[5]+3,25);
traps.c:			SET_BIT(obj->extra_flags[1],ITEM_WIZI);  // Trap is installed
traps.c:			obj->set_by = ch;
traps.c:				obj->next_trap = NULL;
traps.c:				obj->next_trap = ch->trap_list;
traps.c:for (obj = room->contents; obj != NULL; obj = obj->next_content)
traps.c:      if ( (( obj->item_type == ITEM_ROOM_TRAP 
traps.c:           || obj->item_type == ITEM_PORTAL_TRAP )) 
traps.c:	&& IS_SET(obj->extra_flags[1],ITEM_WIZI)
traps.c:	&& !IS_SET(obj->value[12],TFLAG_NODETECT))
traps.c:		for (thing = obj->contains; thing != NULL; thing= thing->next_content)
update.c:							pit_obj = pit_obj->next)
update.c:							if (pit_obj->pIndexData->vnum == OBJ_VNUM_PIT)
update.c:				for (obj = ch->in_room->contents; obj; obj = obj->next_content)
update.c:						&& obj->cost > max && obj->cost > 0)
update.c:						if ((obj->item_type == ITEM_FURNITURE || obj->item_type == ITEM_RAFT) &&
update.c:						if (obj->item_type == ITEM_CTRANSPORT)
update.c:						max = obj->cost;
update.c:						&& obj->item_type == ITEM_LIGHT
update.c:						&& obj->value[2] != 0 && ch->in_room != NULL))
update.c:									obj_next = obj->next_content;
update.c:				for (obj = ch->carrying; obj != NULL; obj = obj->next_content)
update.c:					if (obj->item_type == ITEM_GILLS
update.c:						&& obj->wear_loc != WEAR_NONE)
update.c:				for (obj = ch->carrying; obj != NULL; obj = obj->next_content)
update.c:					if ((obj->item_type == ITEM_GILLS
update.c:						&& obj->wear_loc != WEAR_NONE))
update.c:				&& obj->item_type == ITEM_LIGHT && obj->value[2] > 0)
update.c:				if (--obj->value[2] == 0 && ch->in_room != NULL)
update.c:				else if (obj->value[2] <= 5 && ch->in_room != NULL)
update.c:		obj_next = obj->next;
update.c:		for (paf = obj->affected; paf != NULL; paf = paf_next)
update.c:						if (obj->carried_by != NULL)
update.c:							rch = obj->carried_by;
update.c:						if (obj->in_room != NULL
update.c:							&& obj->in_room->people != NULL)
update.c:							rch = obj->in_room->people;
update.c:		if (obj->item_type == ITEM_WRITING_PAPER && obj->value[0] >= 0)
update.c:			if (obj->value[0] > 0)
update.c:				obj->value[0]--;
update.c:			if (obj->value == 0)
update.c:				for (ed = obj->extra_descr; ed != NULL; ed = ed->next)
update.c:					obj->value[0] = obj->pIndexData->value[0];
update.c:		if (obj->timer <= 0 || --obj->timer > 0)
update.c:		if (obj->pIndexData->vnum == OBJ_VNUM_CAMPFIRE1)
update.c:			inroom = obj->in_room;
update.c:				oldlevel = obj->level;
update.c:				nobj->timer = (oldlevel / 8) / 3;
update.c:				if (nobj->timer < 1)
update.c:					nobj->timer = 1;
update.c:				nobj->level = oldlevel;
update.c:		else if (obj->pIndexData->vnum == OBJ_VNUM_CAMPFIRE2)
update.c:			inroom = obj->in_room;
update.c:				oldlevel = obj->level;
update.c:				nobj->timer = oldlevel / 8;
update.c:				if (nobj->timer < 1)
update.c:					nobj->timer = 1;
update.c:				nobj->level = oldlevel;
update.c:		else if (obj->pIndexData->vnum == OBJ_VNUM_CAMPFIRE3)
update.c:			inroom = obj->in_room;
update.c:		else if (obj->pIndexData->vnum == OBJ_VNUM_PENTAGRAM)
update.c:			inroom = obj->in_room;
update.c:		else if (obj->pIndexData->vnum == OBJ_VNUM_HEXAGRAM)
update.c:			inroom = obj->in_room;
update.c:		else if (obj->pIndexData->vnum == OBJ_VNUM_SEPTAGRAM)
update.c:			inroom = obj->in_room;
update.c:		switch (obj->item_type)
update.c:			if (obj->value[0] == WEAPON_ARROW
update.c:				&& obj->in_obj->item_type == ITEM_QUIVER)
update.c:				if (obj->in_obj->carried_by)
update.c:					obj->in_obj->carried_by->carry_number++;
update.c:				if (obj->contains)
update.c:		if (obj && obj->pIndexData && obj->pIndexData->vnum == OBJ_VNUM_LITAN_FOOTSTEPS)
update.c:			if (obj->value[0] != 1)
update.c:		if (obj->carried_by != NULL)
update.c:			if (IS_NPC (obj->carried_by)
update.c:				&& obj->carried_by->pIndexData->pShop != NULL)
update.c:				obj->carried_by->silver += obj->cost / 5;
update.c:				act (message, obj->carried_by, obj, NULL, TO_CHAR);
update.c:				if (obj->wear_loc == WEAR_FLOAT)
update.c:					act (message, obj->carried_by, obj, NULL, TO_ROOM);
update.c:		else if (obj->in_room != NULL && (rch = obj->in_room->people) != NULL)
update.c:				(obj->in_obj
update.c:				&& obj->in_obj->pIndexData->vnum == OBJ_VNUM_PIT
update.c:				&& !CAN_WEAR (obj->in_obj, ITEM_TAKE)))
update.c:		if ((obj->item_type == ITEM_CORPSE_PC || obj->item_type == ITEM_CORPSE_NPC
update.c:			||CAN_WEAR (obj, ITEM_WEAR_FLOAT)) /*obj->wear_loc == WEAR_FLOAT)*/ && obj->contains)
update.c:			for (t_obj = obj->contains; t_obj != NULL; t_obj = next_obj)
update.c:				next_obj = t_obj->next_content;
update.c:				//	      if (t_obj->pIndexData->vnum == OBJ_VNUM_RUNE_CONV)
update.c:				if (obj->in_obj)
update.c:					obj_to_obj (t_obj, obj->in_obj);
update.c:				else if (obj->carried_by)
update.c:						if (obj->carried_by->in_room == NULL)
update.c:							obj_to_room (t_obj, obj->carried_by->in_room);
update.c:						obj_to_char (t_obj, obj->carried_by);
update.c:				else if (obj->in_room == NULL)
update.c:					obj_to_room (t_obj, obj->in_room);
Utilities.c:    if ((obj->material != NULL) && ((strcmp(obj->material, "silver") == 0) || (strcmp(obj->material, "iron") == 0) ||
Utilities.c:        (strcmp(obj->material, "mithril") == 0) || (strcmp(obj->material, "platinum") == 0) ||
Utilities.c:        (strcmp(obj->material, "lead") == 0) || (strcmp(obj->material, "copper") == 0) ||
Utilities.c:        (strcmp(obj->material, "electrum") == 0) || (strcmp(obj->material, "bronze") == 0) ||
Utilities.c:        (strcmp(obj->material, "brass") == 0) || (strcmp(obj->material, "tin") == 0) ||
Utilities.c:        (strcmp(obj->material, "pewter") == 0) ||  (strcmp(obj->material, "metal") == 0) ||
Utilities.c:        (strcmp(obj->material, "steel") == 0) || (strcmp(obj->material, "gold") == 0) ||
Utilities.c:        (strcmp(obj->material, "adamantite") == 0) || (strcmp(obj->material, "aluminum") == 0))) {
Utilities.c:    if ((obj->material != NULL) && ((strcmp(obj->material, "iron") == 0) || (strcmp(obj->material, "steel") == 0))) {
